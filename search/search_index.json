{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"scan2wiki API Documentation","text":""},{"location":"#scan.amazon","title":"<code>amazon</code>","text":"<p>Created on 12023-11-16</p> <p>@author: wf</p>"},{"location":"#scan.amazon.Amazon","title":"<code>Amazon</code>","text":"<p>lookup products on amazon web site</p> Source code in <code>scan/amazon.py</code> <pre><code>class Amazon:\n    \"\"\"\n    lookup products on amazon web site\n    \"\"\"\n\n    def __init__(self, debug: Optional[bool] = False):\n        \"\"\"\n        constructor\n\n        Args:\n            debug (bool, optional): If set to True, pretty-prints the first product div for debugging.\n        \"\"\"\n        self.debug = debug\n\n    def extract_amazon_products(self, soup: BeautifulSoup) -&gt; List[Product]:\n        \"\"\"\n        Extracts product information from Amazon product listing HTML content.\n\n        Args:\n            soup (BeautifulSoup): Soup object of HTML content of the Amazon product listing page.\n\n        Returns:\n            List[Product]: A list of extracted product information as Product objects.\n        \"\"\"\n        products = []\n        # Find all div elements that match the product listing structure\n        for index, div in enumerate(soup.find_all(\"div\", class_=\"puisg-row\")):\n            product_info = {}\n\n            # Pretty-print the first product div if debug is True\n            if self.debug and index == 0:\n                print(\"Debug - First Product Div:\")\n                print(div.prettify())  # Pretty-print the first div\n\n            # Extracting product title\n            title_div = div.find(\"h2\", class_=\"a-size-mini\")\n            if title_div and title_div.a:\n                product_info[\"title\"] = title_div.a.get_text(strip=True)\n\n            # Extracting product image URL and ASIN\n            image_div = div.find(\"div\", class_=\"s-product-image-container\")\n            if image_div and image_div.a:\n                product_info[\"image_url\"] = image_div.img[\"src\"]\n                link = image_div.a[\"href\"]\n                asin = link.split(\"/dp/\")[-1].split(\"/\")[0]\n                product_info[\"asin\"] = asin\n\n            # Extracting product price\n            price_span = div.find(\"span\", class_=\"a-price\")\n            if price_span and price_span.find(\"span\", class_=\"a-offscreen\"):\n                product_info[\"price\"] = price_span.find(\n                    \"span\", class_=\"a-offscreen\"\n                ).get_text(strip=True)\n                # Replace '\\xa0\u20ac' with ' \u20ac' in price\n                product_info[\"price\"] = product_info.get(\"price\", \"\").replace(\n                    \"\\xa0\", \" \"\n                )\n\n            # Add product info to list if it contains any relevant data\n            # Create a Product instance if title is present\n            if \"title\" in product_info:\n                product = Product(\n                    title=product_info[\"title\"],\n                    image_url=product_info.get(\"image_url\", \"\"),\n                    price=product_info.get(\"price\", \"\"),\n                    asin=product_info.get(\"asin\", \"\"),\n                )\n                products.append(product)\n\n        return products\n\n    def get_headers(self):\n        # Possible components of a user agent string\n        browsers = [\"Chrome\", \"Firefox\", \"Safari\", \"Edge\"]\n        operating_systems = [\n            \"Windows NT 10.0; Win64; x64\",\n            \"Macintosh; Intel Mac OS X 10_15_7\",\n            \"X11; Linux x86_64\",\n        ]\n        platforms = [\n            \"AppleWebKit/537.36 (KHTML, like Gecko)\",\n            \"Gecko/20100101 Firefox/76.0\",\n            \"AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Safari/605.1.15\",\n        ]\n\n        # Randomly select one component from each category\n        browser = random.choice(browsers)\n        os = random.choice(operating_systems)\n        platform = random.choice(platforms)\n\n        # Construct the user agent string\n        user_agent = f\"Mozilla/5.0 ({os}) {platform} {browser}/58.0.3029.110\"\n\n        headers = {\"User-Agent\": user_agent}\n        return headers\n\n    def lookup_products(self, search_key: str):\n        \"\"\"\n        lookup the given search key e.g. ISBN or EAN\n        \"\"\"\n        url = f\"https://www.amazon.de/s?k={search_key}\"\n\n        headers = self.get_headers()\n\n        response = requests.get(url, headers=headers)\n        if response.status_code == 200:\n            soup = BeautifulSoup(response.content, \"html.parser\")\n            product_list = self.extract_amazon_products(soup)\n            return product_list\n        else:\n            msg = f\"lookup for {search_key} failed with HTML status code {response.status_code}\"\n            raise Exception(msg)\n</code></pre>"},{"location":"#scan.amazon.Amazon.__init__","title":"<code>__init__(debug=False)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>If set to True, pretty-prints the first product div for debugging.</p> <code>False</code> Source code in <code>scan/amazon.py</code> <pre><code>def __init__(self, debug: Optional[bool] = False):\n    \"\"\"\n    constructor\n\n    Args:\n        debug (bool, optional): If set to True, pretty-prints the first product div for debugging.\n    \"\"\"\n    self.debug = debug\n</code></pre>"},{"location":"#scan.amazon.Amazon.extract_amazon_products","title":"<code>extract_amazon_products(soup)</code>","text":"<p>Extracts product information from Amazon product listing HTML content.</p> <p>Parameters:</p> Name Type Description Default <code>soup</code> <code>BeautifulSoup</code> <p>Soup object of HTML content of the Amazon product listing page.</p> required <p>Returns:</p> Type Description <code>List[Product]</code> <p>List[Product]: A list of extracted product information as Product objects.</p> Source code in <code>scan/amazon.py</code> <pre><code>def extract_amazon_products(self, soup: BeautifulSoup) -&gt; List[Product]:\n    \"\"\"\n    Extracts product information from Amazon product listing HTML content.\n\n    Args:\n        soup (BeautifulSoup): Soup object of HTML content of the Amazon product listing page.\n\n    Returns:\n        List[Product]: A list of extracted product information as Product objects.\n    \"\"\"\n    products = []\n    # Find all div elements that match the product listing structure\n    for index, div in enumerate(soup.find_all(\"div\", class_=\"puisg-row\")):\n        product_info = {}\n\n        # Pretty-print the first product div if debug is True\n        if self.debug and index == 0:\n            print(\"Debug - First Product Div:\")\n            print(div.prettify())  # Pretty-print the first div\n\n        # Extracting product title\n        title_div = div.find(\"h2\", class_=\"a-size-mini\")\n        if title_div and title_div.a:\n            product_info[\"title\"] = title_div.a.get_text(strip=True)\n\n        # Extracting product image URL and ASIN\n        image_div = div.find(\"div\", class_=\"s-product-image-container\")\n        if image_div and image_div.a:\n            product_info[\"image_url\"] = image_div.img[\"src\"]\n            link = image_div.a[\"href\"]\n            asin = link.split(\"/dp/\")[-1].split(\"/\")[0]\n            product_info[\"asin\"] = asin\n\n        # Extracting product price\n        price_span = div.find(\"span\", class_=\"a-price\")\n        if price_span and price_span.find(\"span\", class_=\"a-offscreen\"):\n            product_info[\"price\"] = price_span.find(\n                \"span\", class_=\"a-offscreen\"\n            ).get_text(strip=True)\n            # Replace '\\xa0\u20ac' with ' \u20ac' in price\n            product_info[\"price\"] = product_info.get(\"price\", \"\").replace(\n                \"\\xa0\", \" \"\n            )\n\n        # Add product info to list if it contains any relevant data\n        # Create a Product instance if title is present\n        if \"title\" in product_info:\n            product = Product(\n                title=product_info[\"title\"],\n                image_url=product_info.get(\"image_url\", \"\"),\n                price=product_info.get(\"price\", \"\"),\n                asin=product_info.get(\"asin\", \"\"),\n            )\n            products.append(product)\n\n    return products\n</code></pre>"},{"location":"#scan.amazon.Amazon.lookup_products","title":"<code>lookup_products(search_key)</code>","text":"<p>lookup the given search key e.g. ISBN or EAN</p> Source code in <code>scan/amazon.py</code> <pre><code>def lookup_products(self, search_key: str):\n    \"\"\"\n    lookup the given search key e.g. ISBN or EAN\n    \"\"\"\n    url = f\"https://www.amazon.de/s?k={search_key}\"\n\n    headers = self.get_headers()\n\n    response = requests.get(url, headers=headers)\n    if response.status_code == 200:\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        product_list = self.extract_amazon_products(soup)\n        return product_list\n    else:\n        msg = f\"lookup for {search_key} failed with HTML status code {response.status_code}\"\n        raise Exception(msg)\n</code></pre>"},{"location":"#scan.barcode","title":"<code>barcode</code>","text":"<p>Created on 2023-11-16</p> <p>@author: wf</p>"},{"location":"#scan.barcode.Barcode","title":"<code>Barcode</code>  <code>dataclass</code>","text":"<p>Barcode data structure with static methods e.g.  e.g. pyzbar barcode decoder wrapper</p> Source code in <code>scan/barcode.py</code> <pre><code>@dataclass\nclass Barcode:\n    \"\"\"\n    Barcode data structure with\n    static methods e.g.  e.g. pyzbar barcode decoder wrapper\n    \"\"\"\n\n    code: str\n    type: str\n    orientation: str\n    rect: Optional[dict] = None\n    polygon: Optional[List[dict]] = None\n    quality: Optional[int] = None\n\n    @staticmethod\n    def decode(image_file_path: str, debug: bool = False):\n        \"\"\"\n        Decodes barcodes from the image at the given file path.\n\n        Args:\n            image_file_path (str): The file path of the image to decode.\n            debug (bool): If False, suppress debug information of the PIL library. Default is False.\n\n        Returns:\n            list[Barcode]: A list of Barcode objects, or an empty list if no barcodes are found.\n        \"\"\"\n        if not debug:\n            # Suppress debug messages\n            logging.getLogger(\"PIL\").setLevel(logging.INFO)\n        # Open the saved image\n        image = Image.open(image_file_path)\n        # Decode barcodes\n        barcodes = decode(image)\n        barcode_list = [\n            Barcode(\n                code=barcode.data.decode(\"utf-8\"),\n                type=barcode.type,\n                rect=barcode.rect._asdict(),\n                polygon=[point._asdict() for point in barcode.polygon],\n                quality=barcode.quality,\n                orientation=barcode.orientation,\n            )\n            for barcode in barcodes\n        ]\n        return barcode_list\n</code></pre>"},{"location":"#scan.barcode.Barcode.decode","title":"<code>decode(image_file_path, debug=False)</code>  <code>staticmethod</code>","text":"<p>Decodes barcodes from the image at the given file path.</p> <p>Parameters:</p> Name Type Description Default <code>image_file_path</code> <code>str</code> <p>The file path of the image to decode.</p> required <code>debug</code> <code>bool</code> <p>If False, suppress debug information of the PIL library. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <p>list[Barcode]: A list of Barcode objects, or an empty list if no barcodes are found.</p> Source code in <code>scan/barcode.py</code> <pre><code>@staticmethod\ndef decode(image_file_path: str, debug: bool = False):\n    \"\"\"\n    Decodes barcodes from the image at the given file path.\n\n    Args:\n        image_file_path (str): The file path of the image to decode.\n        debug (bool): If False, suppress debug information of the PIL library. Default is False.\n\n    Returns:\n        list[Barcode]: A list of Barcode objects, or an empty list if no barcodes are found.\n    \"\"\"\n    if not debug:\n        # Suppress debug messages\n        logging.getLogger(\"PIL\").setLevel(logging.INFO)\n    # Open the saved image\n    image = Image.open(image_file_path)\n    # Decode barcodes\n    barcodes = decode(image)\n    barcode_list = [\n        Barcode(\n            code=barcode.data.decode(\"utf-8\"),\n            type=barcode.type,\n            rect=barcode.rect._asdict(),\n            polygon=[point._asdict() for point in barcode.polygon],\n            quality=barcode.quality,\n            orientation=barcode.orientation,\n        )\n        for barcode in barcodes\n    ]\n    return barcode_list\n</code></pre>"},{"location":"#scan.dms","title":"<code>dms</code>","text":"<p>Created on 2021-10-21</p> <p>@author: wf</p> <p>see http://diagrams.bitplan.com/render/png/0xe1f1d160.png see http://diagrams.bitplan.com/render/txt/0xe1f1d160.txt</p>"},{"location":"#scan.dms.Archive","title":"<code>Archive</code>","text":"<p>               Bases: <code>JSONAble</code></p> <p>an Archive might be a filesystem on a server or a (semantic) mediawiki</p> Source code in <code>scan/dms.py</code> <pre><code>class Archive(JSONAble):\n    \"\"\"\n    an Archive might be a filesystem\n    on a server or a (semantic) mediawiki\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructor\n        \"\"\"\n\n    @classmethod\n    def getSamples(cls):\n        samplesLOD = [\n            {\n                \"server\": \"wiki.bitplan.com\",\n                \"name\": \"wiki\",\n                \"url\": \"http://wiki.bitplan.com\",\n                \"wikiid\": \"wiki\",\n                \"folderCount\": 0,\n                \"documentCount\": 0,\n            },\n            {\n                \"server\": \"media.bitplan.com\",\n                \"name\": \"media\",\n                \"url\": \"http://media.bitplan.com\",\n                \"wikiid\": \"media\",\n                \"folderCount\": 9,\n                \"documentCount\": 551,\n            },\n        ]\n        return samplesLOD\n\n    def normalizePageTitle(self, pageTitle):\n        \"\"\"\n        normalize the given pageTitle\n        \"\"\"\n        nPageTitle = pageTitle.replace(\" \", \"_\")\n        return nPageTitle\n\n    def getFoldersAndDocuments(self, withOcr=False):\n        \"\"\"\n        get the folders of this archive\n\n        Return:\n            the list of folders and files\n        \"\"\"\n        foldersByPath = {}\n        documentList = []\n        # this archive is pointing to a wiki\n        if hasattr(self, \"wikiid\") and self.wikiid is not None:\n            smw = Wiki.getSMW(self.wikiid)\n            for option in [\"|format=count\", \"\"]:\n                askQuery = (\n                    \"\"\"{{#ask: [[Category:OCRDocument]]  \n| mainlabel=page\n| ?Category\n| ?Modification date=lastModified\n| ?Creation date=created\n|limit=1000\n%s\n}}\"\"\"\n                    % option\n                )\n                print(askQuery)\n                result = smw.query(askQuery)\n                baseUrl = f\"{smw.site.scheme}://{smw.site.host}{smw.site.path}index.php\"\n                if option == \"\":\n                    folderCounter = Counter()\n                    folderCreated = {}\n                    folderLastModified = {}\n                    for record in result.values():\n                        page = record[\"page\"]\n                        if \"Kategorie\" in record:\n                            catname = \"Kategorie\"\n                            categories = record[\"Kategorie\"]\n                        else:\n                            catname = \"Category\"\n                            categories = record[\"Category\"]\n                        doc = Document()\n                        doc.archiveName = self.name\n                        if isinstance(categories, list):\n                            firstCategory = categories[0]\n                        else:\n                            firstCategory = categories\n                        doc.folderPath = firstCategory.replace(f\"{catname}:\", \"\")\n                        # print(f\"{firstCategory}-&gt;{doc.folderPath}\")\n                        doc.lastModified = record[\"lastModified\"]\n                        doc.created = record[\"created\"]\n                        folderCounter[doc.folderPath] += 1\n                        if doc.created:\n                            if doc.folderPath in folderCreated:\n                                folderCreated[doc.folderPath] = min(\n                                    doc.created, folderCreated[doc.folderPath]\n                                )\n                            else:\n                                folderCreated[doc.folderPath] = doc.created\n                        if doc.lastModified:\n                            if doc.folderPath in folderLastModified:\n                                folderLastModified[doc.folderPath] = max(\n                                    doc.lastModified, folderLastModified[doc.folderPath]\n                                )\n                            else:\n                                folderLastModified[doc.folderPath] = doc.lastModified\n\n                        doc.name = page\n                        doc.url = f\"{baseUrl}/{self.normalizePageTitle(page)}\"\n                        documentList.append(doc)\n                    # collect folders\n                    for folderName, count in folderCounter.most_common():\n                        folder = Folder()\n                        folder.archiveName = self.name\n                        folder.name = folderName\n                        folder.path = folderName\n                        if folderName in folderLastModified:\n                            folder.lastModified = folderLastModified[folderName]\n                        if folderName in folderCreated:\n                            folder.created = folderCreated[folderName]\n                        folder.url = f\"{baseUrl}/Category:{folderName}\"\n                        folder.fileCount = count\n                        foldersByPath[folderName] = folder\n                        pass\n        else:\n            # this archive is pointing to a folder\n            pattern = rf\"http://{self.server}\"\n            folderPath = re.sub(pattern, \"\", self.url)\n            basePath = Folder.getFullpath(folderPath)\n            for root, dirs, files in os.walk(basePath):\n                relbase = Folder.getRelpath(root)\n                # loop over all directories\n                for dirname in dirs:\n                    if not dirname.startswith(\".\"):\n                        folder = Folder()\n                        folder.archive = self\n                        fullpath = os.path.join(root, dirname)\n                        folder.path = os.path.join(relbase, dirname)\n                        folder.archiveName = self.name\n                        folder.url = f\"http://{self.server}{folder.path}\"\n                        folder.name = dirname\n                        # files in folder ...\n                        pdfFiles = folder.getFiles()\n                        folder.fileCount = len(pdfFiles)\n                        folder.lastModified = DMSStorage.getDatetime(fullpath)\n                        folder.created = folder.lastModified\n                        folderDocuments = folder.getDocuments(pdfFiles, withOcr=withOcr)\n                        # add the results\n                        documentList.extend(folderDocuments)\n                        foldersByPath[folder.path] = folder\n            pass\n        return foldersByPath, documentList\n</code></pre>"},{"location":"#scan.dms.Archive.__init__","title":"<code>__init__()</code>","text":"<p>Constructor</p> Source code in <code>scan/dms.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor\n    \"\"\"\n</code></pre>"},{"location":"#scan.dms.Archive.getFoldersAndDocuments","title":"<code>getFoldersAndDocuments(withOcr=False)</code>","text":"<p>get the folders of this archive</p> Return <p>the list of folders and files</p> Source code in <code>scan/dms.py</code> <pre><code>    def getFoldersAndDocuments(self, withOcr=False):\n        \"\"\"\n        get the folders of this archive\n\n        Return:\n            the list of folders and files\n        \"\"\"\n        foldersByPath = {}\n        documentList = []\n        # this archive is pointing to a wiki\n        if hasattr(self, \"wikiid\") and self.wikiid is not None:\n            smw = Wiki.getSMW(self.wikiid)\n            for option in [\"|format=count\", \"\"]:\n                askQuery = (\n                    \"\"\"{{#ask: [[Category:OCRDocument]]  \n| mainlabel=page\n| ?Category\n| ?Modification date=lastModified\n| ?Creation date=created\n|limit=1000\n%s\n}}\"\"\"\n                    % option\n                )\n                print(askQuery)\n                result = smw.query(askQuery)\n                baseUrl = f\"{smw.site.scheme}://{smw.site.host}{smw.site.path}index.php\"\n                if option == \"\":\n                    folderCounter = Counter()\n                    folderCreated = {}\n                    folderLastModified = {}\n                    for record in result.values():\n                        page = record[\"page\"]\n                        if \"Kategorie\" in record:\n                            catname = \"Kategorie\"\n                            categories = record[\"Kategorie\"]\n                        else:\n                            catname = \"Category\"\n                            categories = record[\"Category\"]\n                        doc = Document()\n                        doc.archiveName = self.name\n                        if isinstance(categories, list):\n                            firstCategory = categories[0]\n                        else:\n                            firstCategory = categories\n                        doc.folderPath = firstCategory.replace(f\"{catname}:\", \"\")\n                        # print(f\"{firstCategory}-&gt;{doc.folderPath}\")\n                        doc.lastModified = record[\"lastModified\"]\n                        doc.created = record[\"created\"]\n                        folderCounter[doc.folderPath] += 1\n                        if doc.created:\n                            if doc.folderPath in folderCreated:\n                                folderCreated[doc.folderPath] = min(\n                                    doc.created, folderCreated[doc.folderPath]\n                                )\n                            else:\n                                folderCreated[doc.folderPath] = doc.created\n                        if doc.lastModified:\n                            if doc.folderPath in folderLastModified:\n                                folderLastModified[doc.folderPath] = max(\n                                    doc.lastModified, folderLastModified[doc.folderPath]\n                                )\n                            else:\n                                folderLastModified[doc.folderPath] = doc.lastModified\n\n                        doc.name = page\n                        doc.url = f\"{baseUrl}/{self.normalizePageTitle(page)}\"\n                        documentList.append(doc)\n                    # collect folders\n                    for folderName, count in folderCounter.most_common():\n                        folder = Folder()\n                        folder.archiveName = self.name\n                        folder.name = folderName\n                        folder.path = folderName\n                        if folderName in folderLastModified:\n                            folder.lastModified = folderLastModified[folderName]\n                        if folderName in folderCreated:\n                            folder.created = folderCreated[folderName]\n                        folder.url = f\"{baseUrl}/Category:{folderName}\"\n                        folder.fileCount = count\n                        foldersByPath[folderName] = folder\n                        pass\n        else:\n            # this archive is pointing to a folder\n            pattern = rf\"http://{self.server}\"\n            folderPath = re.sub(pattern, \"\", self.url)\n            basePath = Folder.getFullpath(folderPath)\n            for root, dirs, files in os.walk(basePath):\n                relbase = Folder.getRelpath(root)\n                # loop over all directories\n                for dirname in dirs:\n                    if not dirname.startswith(\".\"):\n                        folder = Folder()\n                        folder.archive = self\n                        fullpath = os.path.join(root, dirname)\n                        folder.path = os.path.join(relbase, dirname)\n                        folder.archiveName = self.name\n                        folder.url = f\"http://{self.server}{folder.path}\"\n                        folder.name = dirname\n                        # files in folder ...\n                        pdfFiles = folder.getFiles()\n                        folder.fileCount = len(pdfFiles)\n                        folder.lastModified = DMSStorage.getDatetime(fullpath)\n                        folder.created = folder.lastModified\n                        folderDocuments = folder.getDocuments(pdfFiles, withOcr=withOcr)\n                        # add the results\n                        documentList.extend(folderDocuments)\n                        foldersByPath[folder.path] = folder\n            pass\n        return foldersByPath, documentList\n</code></pre>"},{"location":"#scan.dms.Archive.normalizePageTitle","title":"<code>normalizePageTitle(pageTitle)</code>","text":"<p>normalize the given pageTitle</p> Source code in <code>scan/dms.py</code> <pre><code>def normalizePageTitle(self, pageTitle):\n    \"\"\"\n    normalize the given pageTitle\n    \"\"\"\n    nPageTitle = pageTitle.replace(\" \", \"_\")\n    return nPageTitle\n</code></pre>"},{"location":"#scan.dms.ArchiveManager","title":"<code>ArchiveManager</code>","text":"<p>               Bases: <code>EntityManager</code></p> <p>manager for Archives</p> Source code in <code>scan/dms.py</code> <pre><code>class ArchiveManager(EntityManager):\n    \"\"\"\n    manager for Archives\n    \"\"\"\n\n    def __init__(self, mode=\"sql\", debug=False):\n        \"\"\"constructor\"\"\"\n        name = \"archive\"\n        entityName = \"Archive\"\n        entityPluralName = \"archives\"\n        listName = entityPluralName\n        clazz = Archive\n        tableName = name\n        config = DMSStorage.getStorageConfig(mode=mode, debug=debug)\n        handleInvalidListTypes = True\n        filterInvalidListTypes = True\n        primaryKey = \"url\"\n        super().__init__(\n            name,\n            entityName,\n            entityPluralName,\n            listName,\n            clazz,\n            tableName,\n            primaryKey,\n            config,\n            handleInvalidListTypes,\n            filterInvalidListTypes,\n            debug,\n        )\n\n    @staticmethod\n    def getInstance(mode=None):\n        if mode is None:\n            ams = ArchiveManager(mode=\"sql\")\n            if not ams.isCached():\n                amj = ArchiveManager(mode=\"json\")\n                amj.fromCache()\n                ams.archives = amj.archives\n                ams.store()\n            am = ams\n            DMSStorage.fromCache(ams)\n            am = ams\n        else:\n            am = ArchiveManager(mode)\n        return am\n\n    @staticmethod\n    def addFilesAndFoldersForArchive(\n        archive=None, withOcr=False, store=False, debug=True\n    ):\n        \"\"\"\n        add Files and folder for the given Archive\n\n        Args:\n            archive(Archive): the archive to add files and folder for\n            store(bool): True if the result should be stored in the storage\n            debug(bool): True if debugging messages should be displayed\n        \"\"\"\n        if archive is None:\n            return\n        folders = []\n        msg = f\"getting folders for {archive.name}\"\n        if debug:\n            print(msg)\n        afoldersByPath, documentList = archive.getFoldersAndDocuments(withOcr=withOcr)\n        folderCount = len(afoldersByPath)\n        msg = f\"found {folderCount} folders in {archive.name}\"\n        folders.extend(afoldersByPath.values())\n        if debug:\n            print(msg)\n        if store:\n            if len(folders) &gt; 0:\n                fms = FolderManager(mode=\"sql\")\n                fms.folders = folders\n                fms.store(append=True, replace=True)\n            if len(documentList) &gt; 0:\n                dms = DocumentManager(mode=\"sql\")\n                dms.documents = documentList\n                dms.store(append=True, replace=True)\n</code></pre>"},{"location":"#scan.dms.ArchiveManager.__init__","title":"<code>__init__(mode='sql', debug=False)</code>","text":"<p>constructor</p> Source code in <code>scan/dms.py</code> <pre><code>def __init__(self, mode=\"sql\", debug=False):\n    \"\"\"constructor\"\"\"\n    name = \"archive\"\n    entityName = \"Archive\"\n    entityPluralName = \"archives\"\n    listName = entityPluralName\n    clazz = Archive\n    tableName = name\n    config = DMSStorage.getStorageConfig(mode=mode, debug=debug)\n    handleInvalidListTypes = True\n    filterInvalidListTypes = True\n    primaryKey = \"url\"\n    super().__init__(\n        name,\n        entityName,\n        entityPluralName,\n        listName,\n        clazz,\n        tableName,\n        primaryKey,\n        config,\n        handleInvalidListTypes,\n        filterInvalidListTypes,\n        debug,\n    )\n</code></pre>"},{"location":"#scan.dms.ArchiveManager.addFilesAndFoldersForArchive","title":"<code>addFilesAndFoldersForArchive(archive=None, withOcr=False, store=False, debug=True)</code>  <code>staticmethod</code>","text":"<p>add Files and folder for the given Archive</p> <p>Parameters:</p> Name Type Description Default <code>archive(Archive)</code> <p>the archive to add files and folder for</p> required <code>store(bool)</code> <p>True if the result should be stored in the storage</p> required <code>debug(bool)</code> <p>True if debugging messages should be displayed</p> required Source code in <code>scan/dms.py</code> <pre><code>@staticmethod\ndef addFilesAndFoldersForArchive(\n    archive=None, withOcr=False, store=False, debug=True\n):\n    \"\"\"\n    add Files and folder for the given Archive\n\n    Args:\n        archive(Archive): the archive to add files and folder for\n        store(bool): True if the result should be stored in the storage\n        debug(bool): True if debugging messages should be displayed\n    \"\"\"\n    if archive is None:\n        return\n    folders = []\n    msg = f\"getting folders for {archive.name}\"\n    if debug:\n        print(msg)\n    afoldersByPath, documentList = archive.getFoldersAndDocuments(withOcr=withOcr)\n    folderCount = len(afoldersByPath)\n    msg = f\"found {folderCount} folders in {archive.name}\"\n    folders.extend(afoldersByPath.values())\n    if debug:\n        print(msg)\n    if store:\n        if len(folders) &gt; 0:\n            fms = FolderManager(mode=\"sql\")\n            fms.folders = folders\n            fms.store(append=True, replace=True)\n        if len(documentList) &gt; 0:\n            dms = DocumentManager(mode=\"sql\")\n            dms.documents = documentList\n            dms.store(append=True, replace=True)\n</code></pre>"},{"location":"#scan.dms.DMSStorage","title":"<code>DMSStorage</code>","text":"<p>Document management system storage configuration</p> Source code in <code>scan/dms.py</code> <pre><code>class DMSStorage:\n    \"\"\"\n    Document management system storage configuration\n    \"\"\"\n\n    profile = True\n    withShowProgress = True\n\n    @staticmethod\n    def getStorageConfig(debug: bool = False, mode=\"sql\") -&gt; StorageConfig:\n        \"\"\"\n        get the storageConfiguration\n\n        Args:\n            debug(bool): if True show debug information\n            mode(str): sql or json\n\n        Return:\n            StorageConfig: the storage configuration to be used\n        \"\"\"\n        if mode == \"sql\":\n            config = StorageConfig.getSQL(debug=debug)\n        elif mode == \"json\":\n            config = StorageConfig.getJSON()\n        elif mode == \"jsonpickle\":\n            config = StorageConfig.getJsonPickle(debug=debug)\n        else:\n            raise Exception(f\"invalid mode {mode}\")\n        config.cacheDirName = \"dms\"\n        cachedir = config.getCachePath()\n        config.profile = DMSStorage.profile\n        config.withShowProgress = DMSStorage.withShowProgress\n        if mode == \"sql\":\n            config.cacheFile = f\"{cachedir}/dms.db\"\n        return config\n\n    @staticmethod\n    def getScanDir():\n        \"\"\"\n        get the scan/watch directory to be used\n\n        Returns:\n            str: the path to the scan directory\n        \"\"\"\n        home = str(Path.home())\n        scandir = f\"{home}/Pictures/scans\"\n        os.makedirs(scandir, exist_ok=True)\n        return scandir\n\n    @staticmethod\n    def getSqlDB():\n        \"\"\"\n        get the SQlite database connection\n        \"\"\"\n        config = DMSStorage.getStorageConfig(mode=\"sql\")\n        # https://stackoverflow.com/a/48234567/1497139\n        sqlDB = SQLDB(config.cacheFile, check_same_thread=False)\n        return sqlDB\n\n    @staticmethod\n    def getDatetime(fullpath: str):\n        \"\"\"\n        get the last modification time\n\n        Args:\n            fullpath(str): the path to get the datetime for\n        \"\"\"\n        timestamp = os.path.getmtime(fullpath)\n        ftime = datetime.fromtimestamp(timestamp)\n        return ftime\n\n    @staticmethod\n    def getTimeStr(fullpath: str):\n        \"\"\"\n        get the last modification time\n\n        Args:\n            fullpath(str): the path to get the time string for\n        \"\"\"\n        ftime = DMSStorage.getDatetime(fullpath)\n        ftimestr = ftime.strftime(\"%Y-%m-%d %H:%M:%S\")\n        return ftimestr\n\n    @staticmethod\n    def fromCache(em: EntityManager):\n        \"\"\"\n        initialize the given entity manager from it's cache\n\n        Args:\n            em(EntityManager): the entity manager to initialize\n        \"\"\"\n        if em.isCached():\n            em.fromCache()\n        else:\n            if em.config.mode is StoreMode.SQL:\n                sqlDB = DMSStorage.getSqlDB()\n                em.initSQLDB(sqlDB)\n</code></pre>"},{"location":"#scan.dms.DMSStorage.fromCache","title":"<code>fromCache(em)</code>  <code>staticmethod</code>","text":"<p>initialize the given entity manager from it's cache</p> <p>Parameters:</p> Name Type Description Default <code>em(EntityManager)</code> <p>the entity manager to initialize</p> required Source code in <code>scan/dms.py</code> <pre><code>@staticmethod\ndef fromCache(em: EntityManager):\n    \"\"\"\n    initialize the given entity manager from it's cache\n\n    Args:\n        em(EntityManager): the entity manager to initialize\n    \"\"\"\n    if em.isCached():\n        em.fromCache()\n    else:\n        if em.config.mode is StoreMode.SQL:\n            sqlDB = DMSStorage.getSqlDB()\n            em.initSQLDB(sqlDB)\n</code></pre>"},{"location":"#scan.dms.DMSStorage.getDatetime","title":"<code>getDatetime(fullpath)</code>  <code>staticmethod</code>","text":"<p>get the last modification time</p> <p>Parameters:</p> Name Type Description Default <code>fullpath(str)</code> <p>the path to get the datetime for</p> required Source code in <code>scan/dms.py</code> <pre><code>@staticmethod\ndef getDatetime(fullpath: str):\n    \"\"\"\n    get the last modification time\n\n    Args:\n        fullpath(str): the path to get the datetime for\n    \"\"\"\n    timestamp = os.path.getmtime(fullpath)\n    ftime = datetime.fromtimestamp(timestamp)\n    return ftime\n</code></pre>"},{"location":"#scan.dms.DMSStorage.getScanDir","title":"<code>getScanDir()</code>  <code>staticmethod</code>","text":"<p>get the scan/watch directory to be used</p> <p>Returns:</p> Name Type Description <code>str</code> <p>the path to the scan directory</p> Source code in <code>scan/dms.py</code> <pre><code>@staticmethod\ndef getScanDir():\n    \"\"\"\n    get the scan/watch directory to be used\n\n    Returns:\n        str: the path to the scan directory\n    \"\"\"\n    home = str(Path.home())\n    scandir = f\"{home}/Pictures/scans\"\n    os.makedirs(scandir, exist_ok=True)\n    return scandir\n</code></pre>"},{"location":"#scan.dms.DMSStorage.getSqlDB","title":"<code>getSqlDB()</code>  <code>staticmethod</code>","text":"<p>get the SQlite database connection</p> Source code in <code>scan/dms.py</code> <pre><code>@staticmethod\ndef getSqlDB():\n    \"\"\"\n    get the SQlite database connection\n    \"\"\"\n    config = DMSStorage.getStorageConfig(mode=\"sql\")\n    # https://stackoverflow.com/a/48234567/1497139\n    sqlDB = SQLDB(config.cacheFile, check_same_thread=False)\n    return sqlDB\n</code></pre>"},{"location":"#scan.dms.DMSStorage.getStorageConfig","title":"<code>getStorageConfig(debug=False, mode='sql')</code>  <code>staticmethod</code>","text":"<p>get the storageConfiguration</p> <p>Parameters:</p> Name Type Description Default <code>debug(bool)</code> <p>if True show debug information</p> required <code>mode(str)</code> <p>sql or json</p> required Return <p>StorageConfig: the storage configuration to be used</p> Source code in <code>scan/dms.py</code> <pre><code>@staticmethod\ndef getStorageConfig(debug: bool = False, mode=\"sql\") -&gt; StorageConfig:\n    \"\"\"\n    get the storageConfiguration\n\n    Args:\n        debug(bool): if True show debug information\n        mode(str): sql or json\n\n    Return:\n        StorageConfig: the storage configuration to be used\n    \"\"\"\n    if mode == \"sql\":\n        config = StorageConfig.getSQL(debug=debug)\n    elif mode == \"json\":\n        config = StorageConfig.getJSON()\n    elif mode == \"jsonpickle\":\n        config = StorageConfig.getJsonPickle(debug=debug)\n    else:\n        raise Exception(f\"invalid mode {mode}\")\n    config.cacheDirName = \"dms\"\n    cachedir = config.getCachePath()\n    config.profile = DMSStorage.profile\n    config.withShowProgress = DMSStorage.withShowProgress\n    if mode == \"sql\":\n        config.cacheFile = f\"{cachedir}/dms.db\"\n    return config\n</code></pre>"},{"location":"#scan.dms.DMSStorage.getTimeStr","title":"<code>getTimeStr(fullpath)</code>  <code>staticmethod</code>","text":"<p>get the last modification time</p> <p>Parameters:</p> Name Type Description Default <code>fullpath(str)</code> <p>the path to get the time string for</p> required Source code in <code>scan/dms.py</code> <pre><code>@staticmethod\ndef getTimeStr(fullpath: str):\n    \"\"\"\n    get the last modification time\n\n    Args:\n        fullpath(str): the path to get the time string for\n    \"\"\"\n    ftime = DMSStorage.getDatetime(fullpath)\n    ftimestr = ftime.strftime(\"%Y-%m-%d %H:%M:%S\")\n    return ftimestr\n</code></pre>"},{"location":"#scan.dms.Document","title":"<code>Document</code>","text":"<p>               Bases: <code>JSONAble</code></p> <p>a document consist of one or more files in the filesystem or a wikipage - the name is the pagetitle or the filename without extension</p> <p>types then has the list of available file types e.g. \"pdf,txt\" for single page Documents  the document is somewhat redundant to the Page concept</p> Source code in <code>scan/dms.py</code> <pre><code>class Document(JSONAble):\n    \"\"\"\n    a document consist of one or more files in the filesystem\n    or a wikipage - the name is the pagetitle\n    or the filename without extension\n\n    types then has the list of available file types e.g. \"pdf,txt\"\n    for single page Documents  the document is somewhat redundant to the Page concept\n    \"\"\"\n\n    @classmethod\n    def getSamples(cls):\n        samplesLOD = [\n            {\n                \"archiveName\": \"bitplan-scan\",\n                \"folderPath\": \"\",\n                # TODO: fullpath, filename, basename and timestampStr not needed\n                \"fullpath\": \"\",\n                \"fileName\": \"\",\n                \"basename\": \"\",\n                \"timestampStr\": \"\",\n                \"pageTitle\": \"\",\n                \"categories\": \"\",\n                \"topic\": \"\",\n                \"url\": \"http://capri.bitplan.com/bitplan/scan/2019/\",\n                \"created\": datetime(2019, 2, 27, 10, 7, 56),\n                \"size\": 15,\n                \"lastModified\": datetime(2019, 2, 27, 10, 7, 56),\n                \"name\": \"2019\",\n                \"types\": \"pdf\",\n                \"ocrText\": \"\",\n            }\n        ]\n        return samplesLOD\n\n    def __init__(self):\n        \"\"\"\n        construct me\n        \"\"\"\n        pass\n\n    def fromDict(self, record):\n        \"\"\"\n        overwrite the from Dict\n        \"\"\"\n        super().fromDict(record)\n        pass\n\n    def fromFile(self, folderPath, file, local=False, withOcr=False):\n        \"\"\"\n        Args:\n            folderPath(str): the directory\n            file(str): the file\n            withOcr(bool): if true get the OCRText\n        \"\"\"\n        self.folderPath = folderPath\n        self.name = file\n        self.fullpath = f\"{Folder.getFullpath(self.folderPath,local)}/{file}\"\n        self.size = os.path.getsize(self.fullpath)\n        self.lastModified = DMSStorage.getDatetime(self.fullpath)\n        self.created = self.lastModified\n        self.timestampStr = DMSStorage.getTimeStr(self.fullpath)\n        self.fileName = Path(self.fullpath).name\n        self.baseName = Path(self.fullpath).stem\n        self.pageTitle = f\"{self.baseName}\"\n\n        self.categories = f\"{datetime.now().year}\"\n        self.topic = \"OCRDocument\"\n        if withOcr:\n            self.getOcrText()\n        pass\n\n    def __str__(self):\n        text = \"Upload:\"\n        self.fields = [\"fileName\", \"ocrText\"]\n        delim = \"\"\n        for fieldname in self.fields:\n            text += \"%s%s=%s\" % (delim, fieldname, self.__dict__[fieldname])\n            delim = \",\"\n        return text\n\n    def getPDFText(self):\n        \"\"\"\n        get my PDF Text\n        \"\"\"\n        pdfText = None\n        if self.fullpath.lower().endswith(\".pdf\"):\n            pdfText = PDFMiner.getPDFText(self.fullpath)\n        return pdfText\n\n    def readTextFromFile(self, fileName: str) -&gt; str:\n        \"\"\"\n        read text from the given fileName\n        \"\"\"\n        try:\n            with open(fileName, \"r\") as textFile:\n                return textFile.read()\n        except UnicodeDecodeError as _ude:\n            # print(f\"couldn't decode {fileName}\")\n            with open(fileName, \"rb\") as file:\n                content = file.read()\n                suggestion = UnicodeDammit(content)\n                encoding = suggestion.original_encoding\n                if encoding is None:\n                    encoding = \"utf-8\"\n                try:\n                    text = content.decode(encoding)\n                except Exception as ex:\n                    raise (ex)\n                return text\n\n    def getOcrText(self):\n        \"\"\"\n        get the OCR\n        \"\"\"\n        parent = Path(self.fullpath).parent.absolute()\n        ocrPath = f\"{parent}/.ocr\"\n        self.ocrText = None\n        if os.path.isdir(ocrPath):\n            ocrFileName = f\"{ocrPath}/{self.basename}.txt\"\n            if os.path.isfile(ocrFileName):\n                self.ocrText = self.readTextFromFile(ocrFileName)\n            else:\n                page = 1\n                maxPages = 1000\n                pageFileName = f\"{ocrPath}/{self.basename}_p{page:03d}.txt\"\n                if os.path.isfile(pageFileName):\n                    pageText = self.readTextFromFile(pageFileName)\n                    if pageText is not None:\n                        self.ocrText = pageText\n                        for page in range(2, maxPages):\n                            pageFileName = f\"{ocrPath}/{self.basename}_p{page:03d}.txt\"\n                            if not os.path.isfile(pageFileName):\n                                break\n                            nextPage = self.readTextFromFile(pageFileName)\n                            if nextPage is not None:\n                                self.ocrText += nextPage\n        if self.ocrText is None:\n            self.ocrText = self.getPDFText()\n        return self.ocrText\n\n    def uploadFile(self, wikiId):\n        \"\"\"\n        call back\n        \"\"\"\n        pageContent = self.getContent()\n        ignoreExists = True\n        wikipush = WikiPush(fromWikiId=None, toWikiId=wikiId, login=True)\n        description = f\"scanned at {self.timestampStr}\"\n        msg = f\"uploading {self.pageTitle} ({self.fileName}) to {wikiId} ... \"\n        files = [self.fullpath]\n        wikipush.upload(files, force=ignoreExists)\n        pageToBeEdited = wikipush.toWiki.getPage(self.pageTitle)\n        if (not pageToBeEdited.exists) or ignoreExists:\n            pageToBeEdited.edit(pageContent, description)\n            wikipush.log(msg + \"\u2705\")\n            pass\n\n    def getContent(self):\n        \"\"\"\n        get my content\n\n        Return:\n            str: the content of the wikipage\n        \"\"\"\n        wikicats = \"\"\n        delim = \"\"\n        for category in self.categories.split(\",\"):\n            wikicats += \"%s[[Category:%s]]\" % (delim, category)\n            delim = \"\\n\"\n        if self.fileName.endswith(\".pdf\"):\n            template = \"\"\"= pdf pages =\n&lt;pdf&gt;%s&lt;/pdf&gt;\n= text =\n&lt;pre&gt;%s&lt;/pre&gt;\n= pdf =\n[[File:%s]]\n%s\n&lt;headertabs/&gt;\n\"\"\"\n            pageContent = template % (\n                self.fileName,\n                self.ocrText,\n                self.fileName,\n                wikicats,\n            )\n        else:\n            template = \"\"\"[[File:%s]]\n%s\n&lt;headertabs/&gt;\"\"\"\n            pageContent = template % (self.fileName, wikicats)\n\n        return pageContent\n</code></pre>"},{"location":"#scan.dms.Document.__init__","title":"<code>__init__()</code>","text":"<p>construct me</p> Source code in <code>scan/dms.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    construct me\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#scan.dms.Document.fromDict","title":"<code>fromDict(record)</code>","text":"<p>overwrite the from Dict</p> Source code in <code>scan/dms.py</code> <pre><code>def fromDict(self, record):\n    \"\"\"\n    overwrite the from Dict\n    \"\"\"\n    super().fromDict(record)\n    pass\n</code></pre>"},{"location":"#scan.dms.Document.fromFile","title":"<code>fromFile(folderPath, file, local=False, withOcr=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>folderPath(str)</code> <p>the directory</p> required <code>file(str)</code> <p>the file</p> required <code>withOcr(bool)</code> <p>if true get the OCRText</p> required Source code in <code>scan/dms.py</code> <pre><code>def fromFile(self, folderPath, file, local=False, withOcr=False):\n    \"\"\"\n    Args:\n        folderPath(str): the directory\n        file(str): the file\n        withOcr(bool): if true get the OCRText\n    \"\"\"\n    self.folderPath = folderPath\n    self.name = file\n    self.fullpath = f\"{Folder.getFullpath(self.folderPath,local)}/{file}\"\n    self.size = os.path.getsize(self.fullpath)\n    self.lastModified = DMSStorage.getDatetime(self.fullpath)\n    self.created = self.lastModified\n    self.timestampStr = DMSStorage.getTimeStr(self.fullpath)\n    self.fileName = Path(self.fullpath).name\n    self.baseName = Path(self.fullpath).stem\n    self.pageTitle = f\"{self.baseName}\"\n\n    self.categories = f\"{datetime.now().year}\"\n    self.topic = \"OCRDocument\"\n    if withOcr:\n        self.getOcrText()\n    pass\n</code></pre>"},{"location":"#scan.dms.Document.getContent","title":"<code>getContent()</code>","text":"<p>get my content</p> Return <p>str: the content of the wikipage</p> Source code in <code>scan/dms.py</code> <pre><code>    def getContent(self):\n        \"\"\"\n        get my content\n\n        Return:\n            str: the content of the wikipage\n        \"\"\"\n        wikicats = \"\"\n        delim = \"\"\n        for category in self.categories.split(\",\"):\n            wikicats += \"%s[[Category:%s]]\" % (delim, category)\n            delim = \"\\n\"\n        if self.fileName.endswith(\".pdf\"):\n            template = \"\"\"= pdf pages =\n&lt;pdf&gt;%s&lt;/pdf&gt;\n= text =\n&lt;pre&gt;%s&lt;/pre&gt;\n= pdf =\n[[File:%s]]\n%s\n&lt;headertabs/&gt;\n\"\"\"\n            pageContent = template % (\n                self.fileName,\n                self.ocrText,\n                self.fileName,\n                wikicats,\n            )\n        else:\n            template = \"\"\"[[File:%s]]\n%s\n&lt;headertabs/&gt;\"\"\"\n            pageContent = template % (self.fileName, wikicats)\n\n        return pageContent\n</code></pre>"},{"location":"#scan.dms.Document.getOcrText","title":"<code>getOcrText()</code>","text":"<p>get the OCR</p> Source code in <code>scan/dms.py</code> <pre><code>def getOcrText(self):\n    \"\"\"\n    get the OCR\n    \"\"\"\n    parent = Path(self.fullpath).parent.absolute()\n    ocrPath = f\"{parent}/.ocr\"\n    self.ocrText = None\n    if os.path.isdir(ocrPath):\n        ocrFileName = f\"{ocrPath}/{self.basename}.txt\"\n        if os.path.isfile(ocrFileName):\n            self.ocrText = self.readTextFromFile(ocrFileName)\n        else:\n            page = 1\n            maxPages = 1000\n            pageFileName = f\"{ocrPath}/{self.basename}_p{page:03d}.txt\"\n            if os.path.isfile(pageFileName):\n                pageText = self.readTextFromFile(pageFileName)\n                if pageText is not None:\n                    self.ocrText = pageText\n                    for page in range(2, maxPages):\n                        pageFileName = f\"{ocrPath}/{self.basename}_p{page:03d}.txt\"\n                        if not os.path.isfile(pageFileName):\n                            break\n                        nextPage = self.readTextFromFile(pageFileName)\n                        if nextPage is not None:\n                            self.ocrText += nextPage\n    if self.ocrText is None:\n        self.ocrText = self.getPDFText()\n    return self.ocrText\n</code></pre>"},{"location":"#scan.dms.Document.getPDFText","title":"<code>getPDFText()</code>","text":"<p>get my PDF Text</p> Source code in <code>scan/dms.py</code> <pre><code>def getPDFText(self):\n    \"\"\"\n    get my PDF Text\n    \"\"\"\n    pdfText = None\n    if self.fullpath.lower().endswith(\".pdf\"):\n        pdfText = PDFMiner.getPDFText(self.fullpath)\n    return pdfText\n</code></pre>"},{"location":"#scan.dms.Document.readTextFromFile","title":"<code>readTextFromFile(fileName)</code>","text":"<p>read text from the given fileName</p> Source code in <code>scan/dms.py</code> <pre><code>def readTextFromFile(self, fileName: str) -&gt; str:\n    \"\"\"\n    read text from the given fileName\n    \"\"\"\n    try:\n        with open(fileName, \"r\") as textFile:\n            return textFile.read()\n    except UnicodeDecodeError as _ude:\n        # print(f\"couldn't decode {fileName}\")\n        with open(fileName, \"rb\") as file:\n            content = file.read()\n            suggestion = UnicodeDammit(content)\n            encoding = suggestion.original_encoding\n            if encoding is None:\n                encoding = \"utf-8\"\n            try:\n                text = content.decode(encoding)\n            except Exception as ex:\n                raise (ex)\n            return text\n</code></pre>"},{"location":"#scan.dms.Document.uploadFile","title":"<code>uploadFile(wikiId)</code>","text":"<p>call back</p> Source code in <code>scan/dms.py</code> <pre><code>def uploadFile(self, wikiId):\n    \"\"\"\n    call back\n    \"\"\"\n    pageContent = self.getContent()\n    ignoreExists = True\n    wikipush = WikiPush(fromWikiId=None, toWikiId=wikiId, login=True)\n    description = f\"scanned at {self.timestampStr}\"\n    msg = f\"uploading {self.pageTitle} ({self.fileName}) to {wikiId} ... \"\n    files = [self.fullpath]\n    wikipush.upload(files, force=ignoreExists)\n    pageToBeEdited = wikipush.toWiki.getPage(self.pageTitle)\n    if (not pageToBeEdited.exists) or ignoreExists:\n        pageToBeEdited.edit(pageContent, description)\n        wikipush.log(msg + \"\u2705\")\n        pass\n</code></pre>"},{"location":"#scan.dms.DocumentManager","title":"<code>DocumentManager</code>","text":"<p>               Bases: <code>EntityManager</code></p> <p>manager for Documents</p> Source code in <code>scan/dms.py</code> <pre><code>class DocumentManager(EntityManager):\n    \"\"\"\n    manager for Documents\n    \"\"\"\n\n    def __init__(self, mode=\"sql\", debug=False):\n        \"\"\"constructor\"\"\"\n        name = \"document\"\n        entityName = \"Document\"\n        entityPluralName = \"documents\"\n        listName = entityPluralName\n        clazz = Document\n        tableName = name\n        config = DMSStorage.getStorageConfig(mode=mode, debug=debug)\n        handleInvalidListTypes = True\n        filterInvalidListTypes = True\n        primaryKey = \"url\"\n        super().__init__(\n            name,\n            entityName,\n            entityPluralName,\n            listName,\n            clazz,\n            tableName,\n            primaryKey,\n            config,\n            handleInvalidListTypes,\n            filterInvalidListTypes,\n            debug,\n        )\n\n    @staticmethod\n    def getInstance(mode=\"sql\"):\n        dm = DocumentManager(mode=mode)\n        DMSStorage.fromCache(dm)\n        return dm\n</code></pre>"},{"location":"#scan.dms.DocumentManager.__init__","title":"<code>__init__(mode='sql', debug=False)</code>","text":"<p>constructor</p> Source code in <code>scan/dms.py</code> <pre><code>def __init__(self, mode=\"sql\", debug=False):\n    \"\"\"constructor\"\"\"\n    name = \"document\"\n    entityName = \"Document\"\n    entityPluralName = \"documents\"\n    listName = entityPluralName\n    clazz = Document\n    tableName = name\n    config = DMSStorage.getStorageConfig(mode=mode, debug=debug)\n    handleInvalidListTypes = True\n    filterInvalidListTypes = True\n    primaryKey = \"url\"\n    super().__init__(\n        name,\n        entityName,\n        entityPluralName,\n        listName,\n        clazz,\n        tableName,\n        primaryKey,\n        config,\n        handleInvalidListTypes,\n        filterInvalidListTypes,\n        debug,\n    )\n</code></pre>"},{"location":"#scan.dms.Folder","title":"<code>Folder</code>","text":"<p>               Bases: <code>JSONAble</code></p> <p>a Folder might be a filesystem folder or a category in a wiki</p> Source code in <code>scan/dms.py</code> <pre><code>class Folder(JSONAble):\n    \"\"\"\n    a Folder might be a filesystem folder or a category in a wiki\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructor\n        \"\"\"\n\n    @classmethod\n    def getSamples(cls):\n        samplesLOD = [\n            {\n                \"archiveName\": \"bitplan-scan\",\n                \"url\": \"http://capri.bitplan.com/bitplan/scan/2019/\",\n                \"fileCount\": 15,\n                \"lastModified\": datetime(2019, 2, 27, 10, 7, 56),\n                \"created\": datetime(2019, 2, 27, 10, 7, 56),\n                \"name\": \"2019\",\n                \"path\": \"/bitplan/scan/2019\",\n            }\n        ]\n        return samplesLOD\n\n    @classmethod\n    def getPrefix(cls):\n        \"\"\"\n        get the path prefix for this platform (if any)\n\n        Return:\n            str: the prefix e.g. /Volumes on Darwin\n        \"\"\"\n        if sys.platform == \"darwin\":\n            prefix = f\"/Volumes\"\n        else:\n            prefix = \"\"\n        return prefix\n\n    @staticmethod\n    def getFullpath(folderPath: str, local: bool = False):\n        \"\"\"\n        get the full path as accessible on my platform\n\n        Args:\n           folderPath(str): the path of the folder\n           local(bool): True if the path is for a local folder\n\n        Return:\n            str: the full path of the folder\n        \"\"\"\n        if local:\n            fullPath = folderPath\n        else:\n            fullPath = f\"{Folder.getPrefix()}{folderPath}\"\n        return fullPath\n\n    @classmethod\n    def getRelpath(cls, folderPath: str) -&gt; str:\n        \"\"\"\n        get the relative path as accessible on my platform\n\n        Args:\n           folderPath(str): the path of the folder\n\n        Return:\n            str: the relative path of the folder\n        \"\"\"\n        prefix = Folder.getPrefix()\n        if prefix and folderPath.startswith(prefix):\n            relbase = folderPath.replace(prefix, \"\")\n        else:\n            relbase = folderPath\n        return relbase\n\n    def getFiles(self, extension=\".pdf\"):\n        \"\"\"\n        get all files with the given extension\n\n        Args:\n            extension(str): the extension to search for\n\n        Return:\n            list: the files with the given extension\n        \"\"\"\n        files = []\n        fullPath = Folder.getFullpath(self.path)\n        for file in os.listdir(fullPath):\n            if file.endswith(extension) and not file.startswith(\"._\"):\n                files.append(file)\n        return files\n\n    def getFileDocuments(self):\n        \"\"\"\n        get all documents for the OCRDocument files in this folder\n\n        Return:\n            list: the list of documents\n        \"\"\"\n        files = self.getFiles()\n        documents = self.getDocuments(files)\n        return documents\n\n    def getDocuments(self, files, withOcr=False):\n        \"\"\"\n        get the documents for this folder based on the files from my listdir\n        \"\"\"\n        documentList = []\n        msg = f\"getting {len(files)} documents for {self.path}\"\n        Logger.log(msg)\n        for file in files:\n            try:\n                if file.endswith(\".pdf\"):\n                    doc = Document()\n                    doc.archiveName = self.archiveName\n                    doc.url = f\"http://{self.archive.server}{self.path}/{file}\"\n                    doc.fromFile(self.path, file, withOcr=withOcr)\n                    documentList.append(doc)\n            except Exception as e:\n                Logger.logException(e)\n        return documentList\n\n    def refreshDocuments(self):\n        \"\"\"\n        refresh the documents in this folder\n        \"\"\"\n        doclist = self.getFileDocuments()\n        for doc in doclist:\n            doc.getOcrText()\n            pass\n        pass\n</code></pre>"},{"location":"#scan.dms.Folder.__init__","title":"<code>__init__()</code>","text":"<p>Constructor</p> Source code in <code>scan/dms.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor\n    \"\"\"\n</code></pre>"},{"location":"#scan.dms.Folder.getDocuments","title":"<code>getDocuments(files, withOcr=False)</code>","text":"<p>get the documents for this folder based on the files from my listdir</p> Source code in <code>scan/dms.py</code> <pre><code>def getDocuments(self, files, withOcr=False):\n    \"\"\"\n    get the documents for this folder based on the files from my listdir\n    \"\"\"\n    documentList = []\n    msg = f\"getting {len(files)} documents for {self.path}\"\n    Logger.log(msg)\n    for file in files:\n        try:\n            if file.endswith(\".pdf\"):\n                doc = Document()\n                doc.archiveName = self.archiveName\n                doc.url = f\"http://{self.archive.server}{self.path}/{file}\"\n                doc.fromFile(self.path, file, withOcr=withOcr)\n                documentList.append(doc)\n        except Exception as e:\n            Logger.logException(e)\n    return documentList\n</code></pre>"},{"location":"#scan.dms.Folder.getFileDocuments","title":"<code>getFileDocuments()</code>","text":"<p>get all documents for the OCRDocument files in this folder</p> Return <p>list: the list of documents</p> Source code in <code>scan/dms.py</code> <pre><code>def getFileDocuments(self):\n    \"\"\"\n    get all documents for the OCRDocument files in this folder\n\n    Return:\n        list: the list of documents\n    \"\"\"\n    files = self.getFiles()\n    documents = self.getDocuments(files)\n    return documents\n</code></pre>"},{"location":"#scan.dms.Folder.getFiles","title":"<code>getFiles(extension='.pdf')</code>","text":"<p>get all files with the given extension</p> <p>Parameters:</p> Name Type Description Default <code>extension(str)</code> <p>the extension to search for</p> required Return <p>list: the files with the given extension</p> Source code in <code>scan/dms.py</code> <pre><code>def getFiles(self, extension=\".pdf\"):\n    \"\"\"\n    get all files with the given extension\n\n    Args:\n        extension(str): the extension to search for\n\n    Return:\n        list: the files with the given extension\n    \"\"\"\n    files = []\n    fullPath = Folder.getFullpath(self.path)\n    for file in os.listdir(fullPath):\n        if file.endswith(extension) and not file.startswith(\"._\"):\n            files.append(file)\n    return files\n</code></pre>"},{"location":"#scan.dms.Folder.getFullpath","title":"<code>getFullpath(folderPath, local=False)</code>  <code>staticmethod</code>","text":"<p>get the full path as accessible on my platform</p> <p>Parameters:</p> Name Type Description Default <code>folderPath(str)</code> <p>the path of the folder</p> required <code>local(bool)</code> <p>True if the path is for a local folder</p> required Return <p>str: the full path of the folder</p> Source code in <code>scan/dms.py</code> <pre><code>@staticmethod\ndef getFullpath(folderPath: str, local: bool = False):\n    \"\"\"\n    get the full path as accessible on my platform\n\n    Args:\n       folderPath(str): the path of the folder\n       local(bool): True if the path is for a local folder\n\n    Return:\n        str: the full path of the folder\n    \"\"\"\n    if local:\n        fullPath = folderPath\n    else:\n        fullPath = f\"{Folder.getPrefix()}{folderPath}\"\n    return fullPath\n</code></pre>"},{"location":"#scan.dms.Folder.getPrefix","title":"<code>getPrefix()</code>  <code>classmethod</code>","text":"<p>get the path prefix for this platform (if any)</p> Return <p>str: the prefix e.g. /Volumes on Darwin</p> Source code in <code>scan/dms.py</code> <pre><code>@classmethod\ndef getPrefix(cls):\n    \"\"\"\n    get the path prefix for this platform (if any)\n\n    Return:\n        str: the prefix e.g. /Volumes on Darwin\n    \"\"\"\n    if sys.platform == \"darwin\":\n        prefix = f\"/Volumes\"\n    else:\n        prefix = \"\"\n    return prefix\n</code></pre>"},{"location":"#scan.dms.Folder.getRelpath","title":"<code>getRelpath(folderPath)</code>  <code>classmethod</code>","text":"<p>get the relative path as accessible on my platform</p> <p>Parameters:</p> Name Type Description Default <code>folderPath(str)</code> <p>the path of the folder</p> required Return <p>str: the relative path of the folder</p> Source code in <code>scan/dms.py</code> <pre><code>@classmethod\ndef getRelpath(cls, folderPath: str) -&gt; str:\n    \"\"\"\n    get the relative path as accessible on my platform\n\n    Args:\n       folderPath(str): the path of the folder\n\n    Return:\n        str: the relative path of the folder\n    \"\"\"\n    prefix = Folder.getPrefix()\n    if prefix and folderPath.startswith(prefix):\n        relbase = folderPath.replace(prefix, \"\")\n    else:\n        relbase = folderPath\n    return relbase\n</code></pre>"},{"location":"#scan.dms.Folder.refreshDocuments","title":"<code>refreshDocuments()</code>","text":"<p>refresh the documents in this folder</p> Source code in <code>scan/dms.py</code> <pre><code>def refreshDocuments(self):\n    \"\"\"\n    refresh the documents in this folder\n    \"\"\"\n    doclist = self.getFileDocuments()\n    for doc in doclist:\n        doc.getOcrText()\n        pass\n    pass\n</code></pre>"},{"location":"#scan.dms.FolderManager","title":"<code>FolderManager</code>","text":"<p>               Bases: <code>EntityManager</code></p> <p>manager for Archives</p> Source code in <code>scan/dms.py</code> <pre><code>class FolderManager(EntityManager):\n    \"\"\"\n    manager for Archives\n    \"\"\"\n\n    def __init__(self, mode=\"sql\", debug=False):\n        \"\"\"constructor\"\"\"\n        name = \"folder\"\n        entityName = \"Folder\"\n        entityPluralName = \"folders\"\n        listName = entityPluralName\n        clazz = Folder\n        tableName = name\n        config = DMSStorage.getStorageConfig(mode=mode, debug=debug)\n        handleInvalidListTypes = True\n        filterInvalidListTypes = True\n        primaryKey = None\n        super().__init__(\n            name,\n            entityName,\n            entityPluralName,\n            listName,\n            clazz,\n            tableName,\n            primaryKey,\n            config,\n            handleInvalidListTypes,\n            filterInvalidListTypes,\n            debug,\n        )\n\n    @staticmethod\n    def getInstance(mode=\"sql\"):\n        fm = FolderManager(mode=mode)\n        DMSStorage.fromCache(fm)\n        return fm\n\n    def getDocumentRecords(self, archiveName, folderPath):\n        \"\"\"\n        get the document records\n        \"\"\"\n        sqlDB = SQLDB(self.getCacheFile())\n        sqlQuery = \"SELECT * FROM document WHERE archiveName=(?) AND folderPath=(?)\"\n        params = (\n            archiveName,\n            folderPath,\n        )\n        dictList = sqlDB.query(sqlQuery, params)\n        return dictList\n\n    def getFolder(self, archive, folderPath: str):\n        \"\"\"\n        get the folder for the given archive and folderPath\n\n        Args:\n            archive: the  archive\n            folderPath: the path of the folder\n        \"\"\"\n        sqlDB = SQLDB(self.getCacheFile())\n        sqlQuery = \"SELECT * FROM folder WHERE archiveName=(?) AND path=(?)\"\n        archiveName = archive.name\n        params = (\n            archiveName,\n            folderPath,\n        )\n        records = sqlDB.query(sqlQuery, params)\n        folder = None\n        if len(records) &gt; 1:\n            msg = f\"{len(records)} folders found for {archiveName}:{folderPath} - there should be only one\"\n            raise Exception(msg)\n        elif len(records) == 1:\n            folder = Folder()\n            folder.fromDict(records[0])\n        folder.archive = archive\n        return folder\n\n    def refreshFolder(self, archive, folderPath):\n        \"\"\"\n        for the given archive and folderPath\n\n        Args:\n            archive: the name of the archive\n            folderPath: the path of the folder\n        \"\"\"\n        folder = self.getFolder(archive, folderPath)\n        folder.refreshDocuments()\n        pass\n</code></pre>"},{"location":"#scan.dms.FolderManager.__init__","title":"<code>__init__(mode='sql', debug=False)</code>","text":"<p>constructor</p> Source code in <code>scan/dms.py</code> <pre><code>def __init__(self, mode=\"sql\", debug=False):\n    \"\"\"constructor\"\"\"\n    name = \"folder\"\n    entityName = \"Folder\"\n    entityPluralName = \"folders\"\n    listName = entityPluralName\n    clazz = Folder\n    tableName = name\n    config = DMSStorage.getStorageConfig(mode=mode, debug=debug)\n    handleInvalidListTypes = True\n    filterInvalidListTypes = True\n    primaryKey = None\n    super().__init__(\n        name,\n        entityName,\n        entityPluralName,\n        listName,\n        clazz,\n        tableName,\n        primaryKey,\n        config,\n        handleInvalidListTypes,\n        filterInvalidListTypes,\n        debug,\n    )\n</code></pre>"},{"location":"#scan.dms.FolderManager.getDocumentRecords","title":"<code>getDocumentRecords(archiveName, folderPath)</code>","text":"<p>get the document records</p> Source code in <code>scan/dms.py</code> <pre><code>def getDocumentRecords(self, archiveName, folderPath):\n    \"\"\"\n    get the document records\n    \"\"\"\n    sqlDB = SQLDB(self.getCacheFile())\n    sqlQuery = \"SELECT * FROM document WHERE archiveName=(?) AND folderPath=(?)\"\n    params = (\n        archiveName,\n        folderPath,\n    )\n    dictList = sqlDB.query(sqlQuery, params)\n    return dictList\n</code></pre>"},{"location":"#scan.dms.FolderManager.getFolder","title":"<code>getFolder(archive, folderPath)</code>","text":"<p>get the folder for the given archive and folderPath</p> <p>Parameters:</p> Name Type Description Default <code>archive</code> <p>the  archive</p> required <code>folderPath</code> <code>str</code> <p>the path of the folder</p> required Source code in <code>scan/dms.py</code> <pre><code>def getFolder(self, archive, folderPath: str):\n    \"\"\"\n    get the folder for the given archive and folderPath\n\n    Args:\n        archive: the  archive\n        folderPath: the path of the folder\n    \"\"\"\n    sqlDB = SQLDB(self.getCacheFile())\n    sqlQuery = \"SELECT * FROM folder WHERE archiveName=(?) AND path=(?)\"\n    archiveName = archive.name\n    params = (\n        archiveName,\n        folderPath,\n    )\n    records = sqlDB.query(sqlQuery, params)\n    folder = None\n    if len(records) &gt; 1:\n        msg = f\"{len(records)} folders found for {archiveName}:{folderPath} - there should be only one\"\n        raise Exception(msg)\n    elif len(records) == 1:\n        folder = Folder()\n        folder.fromDict(records[0])\n    folder.archive = archive\n    return folder\n</code></pre>"},{"location":"#scan.dms.FolderManager.refreshFolder","title":"<code>refreshFolder(archive, folderPath)</code>","text":"<p>for the given archive and folderPath</p> <p>Parameters:</p> Name Type Description Default <code>archive</code> <p>the name of the archive</p> required <code>folderPath</code> <p>the path of the folder</p> required Source code in <code>scan/dms.py</code> <pre><code>def refreshFolder(self, archive, folderPath):\n    \"\"\"\n    for the given archive and folderPath\n\n    Args:\n        archive: the name of the archive\n        folderPath: the path of the folder\n    \"\"\"\n    folder = self.getFolder(archive, folderPath)\n    folder.refreshDocuments()\n    pass\n</code></pre>"},{"location":"#scan.dms.Wiki","title":"<code>Wiki</code>","text":"<p>               Bases: <code>object</code></p> <p>Semantic Mediawiki access proxy</p> Source code in <code>scan/dms.py</code> <pre><code>class Wiki(object):\n    \"\"\"\n    Semantic Mediawiki access proxy\n    \"\"\"\n\n    @staticmethod\n    def getSMW(wikiId: str):\n        \"\"\"\n        get the semantic mediawiki client with the given wikiId\n\n        Args:\n            wikiId: the wiki id of the client\n\n        Return:\n            SMWClient: the SMWClient with the given id\n        \"\"\"\n        wikiClient = Wiki.get(wikiId)\n        smw = SMWClient(wikiClient.getSite())\n        return smw\n\n    @staticmethod\n    def get(wikiId: str):\n        \"\"\"\n        get the Wiki Client with the given wikiId\n\n        Args:\n            wikiId: the wiki id of the client\n\n        Return:\n            WikiClient: the WikiClient with the given id\n        \"\"\"\n        Wiki.checkIniFile(wikiId)\n        wikiClient = WikiClient.ofWikiId(wikiId)\n        wikiClient.login()\n        return wikiClient\n\n    @staticmethod\n    def inPublicCI():\n        \"\"\"\n        are we running in a public Continuous Integration Environment?\n        \"\"\"\n        return getpass.getuser() in [\"travis\", \"runner\"]\n\n    @staticmethod\n    def checkIniFile(wikiId: str, save=None):\n        \"\"\"\n        check the ini file for the given wikiId\n\n        Args:\n            wikiId(str): the wiki id of the wiki to check\n            save(bool): True if a new ini file should be created e.g. for test purposes\n                        if not set save is True if we are running in a public continuous integration environment\n        \"\"\"\n        if save is None:\n            save = Wiki.inPublicCI()\n        iniFile = WikiUser.iniFilePath(wikiId)\n        if not os.path.isfile(iniFile):\n            wikiDict = None\n            if wikiId == \"wiki\":\n                wikiDict = {\n                    \"wikiId\": wikiId,\n                    \"email\": \"noreply@nouser.com\",\n                    \"url\": \"https://wiki.bitplan.com\",\n                    \"scriptPath\": \"/\",\n                    \"version\": \"MediaWiki 1.35.1\",\n                }\n            if wikiDict is None:\n                raise Exception(\n                    f\"wikiId {wikiId} is not configured in $HOME.mediawiki-japi\"\n                )\n            else:\n                wikiUser = WikiUser.ofDict(wikiDict, lenient=True)\n                if save:\n                    wikiUser.save()\n            pass\n</code></pre>"},{"location":"#scan.dms.Wiki.checkIniFile","title":"<code>checkIniFile(wikiId, save=None)</code>  <code>staticmethod</code>","text":"<p>check the ini file for the given wikiId</p> <p>Parameters:</p> Name Type Description Default <code>wikiId(str)</code> <p>the wiki id of the wiki to check</p> required <code>save(bool)</code> <p>True if a new ini file should be created e.g. for test purposes         if not set save is True if we are running in a public continuous integration environment</p> required Source code in <code>scan/dms.py</code> <pre><code>@staticmethod\ndef checkIniFile(wikiId: str, save=None):\n    \"\"\"\n    check the ini file for the given wikiId\n\n    Args:\n        wikiId(str): the wiki id of the wiki to check\n        save(bool): True if a new ini file should be created e.g. for test purposes\n                    if not set save is True if we are running in a public continuous integration environment\n    \"\"\"\n    if save is None:\n        save = Wiki.inPublicCI()\n    iniFile = WikiUser.iniFilePath(wikiId)\n    if not os.path.isfile(iniFile):\n        wikiDict = None\n        if wikiId == \"wiki\":\n            wikiDict = {\n                \"wikiId\": wikiId,\n                \"email\": \"noreply@nouser.com\",\n                \"url\": \"https://wiki.bitplan.com\",\n                \"scriptPath\": \"/\",\n                \"version\": \"MediaWiki 1.35.1\",\n            }\n        if wikiDict is None:\n            raise Exception(\n                f\"wikiId {wikiId} is not configured in $HOME.mediawiki-japi\"\n            )\n        else:\n            wikiUser = WikiUser.ofDict(wikiDict, lenient=True)\n            if save:\n                wikiUser.save()\n        pass\n</code></pre>"},{"location":"#scan.dms.Wiki.get","title":"<code>get(wikiId)</code>  <code>staticmethod</code>","text":"<p>get the Wiki Client with the given wikiId</p> <p>Parameters:</p> Name Type Description Default <code>wikiId</code> <code>str</code> <p>the wiki id of the client</p> required Return <p>WikiClient: the WikiClient with the given id</p> Source code in <code>scan/dms.py</code> <pre><code>@staticmethod\ndef get(wikiId: str):\n    \"\"\"\n    get the Wiki Client with the given wikiId\n\n    Args:\n        wikiId: the wiki id of the client\n\n    Return:\n        WikiClient: the WikiClient with the given id\n    \"\"\"\n    Wiki.checkIniFile(wikiId)\n    wikiClient = WikiClient.ofWikiId(wikiId)\n    wikiClient.login()\n    return wikiClient\n</code></pre>"},{"location":"#scan.dms.Wiki.getSMW","title":"<code>getSMW(wikiId)</code>  <code>staticmethod</code>","text":"<p>get the semantic mediawiki client with the given wikiId</p> <p>Parameters:</p> Name Type Description Default <code>wikiId</code> <code>str</code> <p>the wiki id of the client</p> required Return <p>SMWClient: the SMWClient with the given id</p> Source code in <code>scan/dms.py</code> <pre><code>@staticmethod\ndef getSMW(wikiId: str):\n    \"\"\"\n    get the semantic mediawiki client with the given wikiId\n\n    Args:\n        wikiId: the wiki id of the client\n\n    Return:\n        SMWClient: the SMWClient with the given id\n    \"\"\"\n    wikiClient = Wiki.get(wikiId)\n    smw = SMWClient(wikiClient.getSite())\n    return smw\n</code></pre>"},{"location":"#scan.dms.Wiki.inPublicCI","title":"<code>inPublicCI()</code>  <code>staticmethod</code>","text":"<p>are we running in a public Continuous Integration Environment?</p> Source code in <code>scan/dms.py</code> <pre><code>@staticmethod\ndef inPublicCI():\n    \"\"\"\n    are we running in a public Continuous Integration Environment?\n    \"\"\"\n    return getpass.getuser() in [\"travis\", \"runner\"]\n</code></pre>"},{"location":"#scan.entity_view","title":"<code>entity_view</code>","text":"<p>Created on 2023-11-17</p> <p>@author: wf</p>"},{"location":"#scan.entity_view.EntityManagerView","title":"<code>EntityManagerView</code>","text":"<p>a view for a given entity manager</p> Source code in <code>scan/entity_view.py</code> <pre><code>class EntityManagerView:\n    \"\"\"\n    a view for a given entity manager\n    \"\"\"\n\n    def __init__(self, em: EntityManager):\n        self.em = em\n        self.setup_view()\n\n    def setup_view(self):\n        \"\"\"\n        set up my view elements\n        \"\"\"\n        self.lod_grid = ListOfDictsGrid()\n\n    def linkColumn(self, name, record, formatWith=None, formatTitleWith=None):\n        \"\"\"\n        replace the column with the given name with a link\n        \"\"\"\n        if name in record:\n            value = record[name]\n            if value is None:\n                record[name] = \"\"\n            else:\n                if formatWith is None:\n                    lurl = value\n                else:\n                    lurl = formatWith % value\n                if formatTitleWith is None:\n                    title = value\n                else:\n                    title = formatTitleWith % value\n                record[name] = Link.create(lurl, title)\n\n    def defaultRowHandler(self, row):\n        self.linkColumn(\"url\", row, formatWith=\"%s\")\n\n    def show(self, rowHandler=None, lodKeyHandler=None):\n        \"\"\"\n        show my given entity manager\n        \"\"\"\n        records = self.em.getList()\n        if len(records) &gt; 0:\n            firstRecord = records[0]\n            lodKeys = list(firstRecord.getJsonTypeSamples()[0].keys())\n        else:\n            lodKeys = [\"url\"]\n        if lodKeyHandler is not None:\n            lodKeyHandler(lodKeys)\n        tableHeaders = lodKeys\n        dictList = [vars(d).copy() for d in records]\n        if rowHandler is None:\n            rowHandler = self.defaultRowHandler\n        for row in dictList:\n            rowHandler(row)\n        title = self.em.entityPluralName\n        self.lod_grid.load_lod(dictList)\n</code></pre>"},{"location":"#scan.entity_view.EntityManagerView.linkColumn","title":"<code>linkColumn(name, record, formatWith=None, formatTitleWith=None)</code>","text":"<p>replace the column with the given name with a link</p> Source code in <code>scan/entity_view.py</code> <pre><code>def linkColumn(self, name, record, formatWith=None, formatTitleWith=None):\n    \"\"\"\n    replace the column with the given name with a link\n    \"\"\"\n    if name in record:\n        value = record[name]\n        if value is None:\n            record[name] = \"\"\n        else:\n            if formatWith is None:\n                lurl = value\n            else:\n                lurl = formatWith % value\n            if formatTitleWith is None:\n                title = value\n            else:\n                title = formatTitleWith % value\n            record[name] = Link.create(lurl, title)\n</code></pre>"},{"location":"#scan.entity_view.EntityManagerView.setup_view","title":"<code>setup_view()</code>","text":"<p>set up my view elements</p> Source code in <code>scan/entity_view.py</code> <pre><code>def setup_view(self):\n    \"\"\"\n    set up my view elements\n    \"\"\"\n    self.lod_grid = ListOfDictsGrid()\n</code></pre>"},{"location":"#scan.entity_view.EntityManagerView.show","title":"<code>show(rowHandler=None, lodKeyHandler=None)</code>","text":"<p>show my given entity manager</p> Source code in <code>scan/entity_view.py</code> <pre><code>def show(self, rowHandler=None, lodKeyHandler=None):\n    \"\"\"\n    show my given entity manager\n    \"\"\"\n    records = self.em.getList()\n    if len(records) &gt; 0:\n        firstRecord = records[0]\n        lodKeys = list(firstRecord.getJsonTypeSamples()[0].keys())\n    else:\n        lodKeys = [\"url\"]\n    if lodKeyHandler is not None:\n        lodKeyHandler(lodKeys)\n    tableHeaders = lodKeys\n    dictList = [vars(d).copy() for d in records]\n    if rowHandler is None:\n        rowHandler = self.defaultRowHandler\n    for row in dictList:\n        rowHandler(row)\n    title = self.em.entityPluralName\n    self.lod_grid.load_lod(dictList)\n</code></pre>"},{"location":"#scan.entity_view.EntityView","title":"<code>EntityView</code>","text":"Source code in <code>scan/entity_view.py</code> <pre><code>class EntityView:\n    \"\"\" \"\"\"\n\n    def __init__(self, entity: JSONAble):\n        \"\"\" \"\"\"\n        self.entity = entity\n</code></pre>"},{"location":"#scan.entity_view.EntityView.__init__","title":"<code>__init__(entity)</code>","text":"Source code in <code>scan/entity_view.py</code> <pre><code>def __init__(self, entity: JSONAble):\n    \"\"\" \"\"\"\n    self.entity = entity\n</code></pre>"},{"location":"#scan.folderwatcher","title":"<code>folderwatcher</code>","text":"<p>Created on 2021-04-21</p> <p>see https://stackoverflow.com/a/66110795/1497139</p>"},{"location":"#scan.folderwatcher.Handler","title":"<code>Handler</code>","text":"<p>               Bases: <code>PatternMatchingEventHandler</code></p> <p>handle changes for a given wildcard pattern</p> Source code in <code>scan/folderwatcher.py</code> <pre><code>class Handler(PatternMatchingEventHandler):\n    \"\"\"\n    handle changes for a given wildcard pattern\n    \"\"\"\n\n    def __init__(self, callback, patterns, debug=False):\n        \"\"\"\n        construct me\n\n        Args:\n            callback: the function to call\n            patterns: the patterns to trigger on\n            debug(bool): if True print debug output\n        \"\"\"\n        self.callback = callback\n        self.debug = debug\n        # Set the patterns for PatternMatchingEventHandler\n        PatternMatchingEventHandler.__init__(\n            self,\n            patterns=patterns,\n            ignore_directories=True,\n            case_sensitive=False,\n        )\n\n    def on_any_event(self, event):\n        if self.debug:\n            print(\n                \"[{}] noticed: [{}] on: [{}] \".format(\n                    time.asctime(), event.event_type, event.src_path\n                )\n            )\n        if \"modified\" == event.event_type:\n            self.callback(event.src_path)\n</code></pre>"},{"location":"#scan.folderwatcher.Handler.__init__","title":"<code>__init__(callback, patterns, debug=False)</code>","text":"<p>construct me</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <p>the function to call</p> required <code>patterns</code> <p>the patterns to trigger on</p> required <code>debug(bool)</code> <p>if True print debug output</p> required Source code in <code>scan/folderwatcher.py</code> <pre><code>def __init__(self, callback, patterns, debug=False):\n    \"\"\"\n    construct me\n\n    Args:\n        callback: the function to call\n        patterns: the patterns to trigger on\n        debug(bool): if True print debug output\n    \"\"\"\n    self.callback = callback\n    self.debug = debug\n    # Set the patterns for PatternMatchingEventHandler\n    PatternMatchingEventHandler.__init__(\n        self,\n        patterns=patterns,\n        ignore_directories=True,\n        case_sensitive=False,\n    )\n</code></pre>"},{"location":"#scan.folderwatcher.Watcher","title":"<code>Watcher</code>","text":"<p>watch the given path with the given callback</p> Source code in <code>scan/folderwatcher.py</code> <pre><code>class Watcher:\n    \"\"\"\n    watch the given path with the given callback\n    \"\"\"\n\n    def __init__(self, path, patterns=[\"*.pdf\", \"*.jpg\"], debug=False):\n        \"\"\"\n        construct me for the given path\n        Args:\n            path(str): the directory to observer\n            patterns(list): a list of wildcard patterns\n            debug(bool): True if debugging should be switched on\n        \"\"\"\n        self.observer = Observer()\n        self.path = path\n        self.patterns = patterns\n        self.debug = debug\n\n    def run(self, callback, sleepTime=1, limit=sys.maxsize):\n        \"\"\"\n        run me\n\n        Args:\n            callback(func): the function to trigger when a file appears\n            sleepTime(float): how often to check for incoming files - default: 1.0 secs\n            limit(float): the maximum time to run the server default: unlimited\n        \"\"\"\n        event_handler = Handler(callback, patterns=self.patterns, debug=self.debug)\n        self.observer.schedule(event_handler, self.path, recursive=True)\n        self.observer.start()\n        runTime = 0\n        try:\n            while runTime &lt; limit:\n                time.sleep(sleepTime)\n                runTime += sleepTime\n\n        except Exception as ex:\n            self.observer.stop()\n            if self.debug:\n                print(\"Error %s \" % str(ex))\n</code></pre>"},{"location":"#scan.folderwatcher.Watcher.__init__","title":"<code>__init__(path, patterns=['*.pdf', '*.jpg'], debug=False)</code>","text":"<p>construct me for the given path Args:     path(str): the directory to observer     patterns(list): a list of wildcard patterns     debug(bool): True if debugging should be switched on</p> Source code in <code>scan/folderwatcher.py</code> <pre><code>def __init__(self, path, patterns=[\"*.pdf\", \"*.jpg\"], debug=False):\n    \"\"\"\n    construct me for the given path\n    Args:\n        path(str): the directory to observer\n        patterns(list): a list of wildcard patterns\n        debug(bool): True if debugging should be switched on\n    \"\"\"\n    self.observer = Observer()\n    self.path = path\n    self.patterns = patterns\n    self.debug = debug\n</code></pre>"},{"location":"#scan.folderwatcher.Watcher.run","title":"<code>run(callback, sleepTime=1, limit=sys.maxsize)</code>","text":"<p>run me</p> <p>Parameters:</p> Name Type Description Default <code>callback(func)</code> <p>the function to trigger when a file appears</p> required <code>sleepTime(float)</code> <p>how often to check for incoming files - default: 1.0 secs</p> required <code>limit(float)</code> <p>the maximum time to run the server default: unlimited</p> required Source code in <code>scan/folderwatcher.py</code> <pre><code>def run(self, callback, sleepTime=1, limit=sys.maxsize):\n    \"\"\"\n    run me\n\n    Args:\n        callback(func): the function to trigger when a file appears\n        sleepTime(float): how often to check for incoming files - default: 1.0 secs\n        limit(float): the maximum time to run the server default: unlimited\n    \"\"\"\n    event_handler = Handler(callback, patterns=self.patterns, debug=self.debug)\n    self.observer.schedule(event_handler, self.path, recursive=True)\n    self.observer.start()\n    runTime = 0\n    try:\n        while runTime &lt; limit:\n            time.sleep(sleepTime)\n            runTime += sleepTime\n\n    except Exception as ex:\n        self.observer.stop()\n        if self.debug:\n            print(\"Error %s \" % str(ex))\n</code></pre>"},{"location":"#scan.logger","title":"<code>logger</code>","text":"<p>Created on 2021-11-02</p> <p>@author: wf</p>"},{"location":"#scan.logger.Logger","title":"<code>Logger</code>","text":"<p>               Bases: <code>object</code></p> <p>a logger module</p> Source code in <code>scan/logger.py</code> <pre><code>class Logger(object):\n    \"\"\"\n    a logger module\n    \"\"\"\n\n    logging.basicConfig(level=logging.DEBUG)\n    logger = logging.getLogger(__name__)\n\n    @staticmethod\n    def log(msg: str):\n        Logger.logger.info(msg)\n\n    @staticmethod\n    def logException(ex):\n        # msg=f\"{ex}\"\n        # print(msg,file=sys.stderr,flush=True)\n        Logger.logger.exception(ex)\n</code></pre>"},{"location":"#scan.pdf","title":"<code>pdf</code>","text":""},{"location":"#scan.pdf.PDFMiner","title":"<code>PDFMiner</code>","text":"<p>PDFMiner.six wrapper to get PDF Text</p> Source code in <code>scan/pdf.py</code> <pre><code>class PDFMiner:\n    \"\"\"\n    PDFMiner.six wrapper to get PDF Text\n    \"\"\"\n\n    @classmethod\n    def getPDFText(cls, pdfFilenamePath, throwError: bool = True):\n        retstr = StringIO()\n        parser = PDFParser(open(pdfFilenamePath, \"rb\"))\n        try:\n            document = PDFDocument(parser)\n        except Exception as e:\n            errMsg = f\"error {pdfFilenamePath}:{str(e)}\"\n            print(errMsg)\n            if throwError:\n                raise e\n            return \"\"\n        if document.is_extractable:\n            rsrcmgr = PDFResourceManager()\n            device = TextConverter(rsrcmgr, retstr, laparams=LAParams())\n            interpreter = PDFPageInterpreter(rsrcmgr, device)\n            for page in PDFPage.create_pages(document):\n                interpreter.process_page(page)\n            return retstr.getvalue()\n        else:\n            print(pdfFilenamePath, \"Warning: could not extract text from pdf file.\")\n            return \"\"\n</code></pre>"},{"location":"#scan.product","title":"<code>product</code>","text":"<p>Created on 2023-11-16</p> <p>@author: wf</p>"},{"location":"#scan.product.Product","title":"<code>Product</code>  <code>dataclass</code>","text":"<p>Data class representing a product.</p> <p>Attributes:</p> Name Type Description <code>title</code> <code>str</code> <p>The title of the product.</p> <code>image_url</code> <code>str</code> <p>The URL of the product image.</p> <code>price</code> <code>str</code> <p>The price of the product.</p> <code>asin</code> <code>Optional[str]</code> <p>The Amazon Standard Identification Number (ASIN) of the product,                   which is a unique identifier on Amazon's platform.</p> Source code in <code>scan/product.py</code> <pre><code>@dataclass\nclass Product:\n    \"\"\"\n    Data class representing a product.\n\n    Attributes:\n        title (str): The title of the product.\n        image_url (str): The URL of the product image.\n        price (str): The price of the product.\n        asin (Optional[str]): The Amazon Standard Identification Number (ASIN) of the product,\n                              which is a unique identifier on Amazon's platform.\n    \"\"\"\n\n    title: str\n    image_url: str\n    price: str\n    asin: Optional[str] = None\n    gtin: Optional[str] = None\n\n    @property\n    def amazon_url(self) -&gt; str:\n        return f\"https://www.amazon.com/dp/{self.asin}\" if self.asin else None\n\n    def as_html(self, img_size: int = 128) -&gt; str:\n        \"\"\"\n        Returns an HTML representation of the product with an image thumbnail and a link to the product page.\n\n        Parameters:\n            img_size (int): Size of the image thumbnail.\n\n        Returns:\n            str: HTML string representation of the product.\n        \"\"\"\n        html = f\"&lt;div&gt;\"\n        html += f'&lt;img src=\"{self.image_url}\" alt=\"{self.title}\" width=\"{img_size}\" height=\"{img_size}\"/&gt;'\n        if self.amazon_url:\n            html += f' &lt;a href=\"{self.amazon_url}\"&gt;{self.title}&lt;/a&gt;'\n        else:\n            html += f\" {self.title}\"\n        if self.gtin:\n            html += f\"Code: {self.gtin}\"\n        html += f\" - {self.price}\"\n        html += f\"&lt;/div&gt;\"\n        return html\n</code></pre>"},{"location":"#scan.product.Product.as_html","title":"<code>as_html(img_size=128)</code>","text":"<p>Returns an HTML representation of the product with an image thumbnail and a link to the product page.</p> <p>Parameters:</p> Name Type Description Default <code>img_size</code> <code>int</code> <p>Size of the image thumbnail.</p> <code>128</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>HTML string representation of the product.</p> Source code in <code>scan/product.py</code> <pre><code>def as_html(self, img_size: int = 128) -&gt; str:\n    \"\"\"\n    Returns an HTML representation of the product with an image thumbnail and a link to the product page.\n\n    Parameters:\n        img_size (int): Size of the image thumbnail.\n\n    Returns:\n        str: HTML string representation of the product.\n    \"\"\"\n    html = f\"&lt;div&gt;\"\n    html += f'&lt;img src=\"{self.image_url}\" alt=\"{self.title}\" width=\"{img_size}\" height=\"{img_size}\"/&gt;'\n    if self.amazon_url:\n        html += f' &lt;a href=\"{self.amazon_url}\"&gt;{self.title}&lt;/a&gt;'\n    else:\n        html += f\" {self.title}\"\n    if self.gtin:\n        html += f\"Code: {self.gtin}\"\n    html += f\" - {self.price}\"\n    html += f\"&lt;/div&gt;\"\n    return html\n</code></pre>"},{"location":"#scan.product.Products","title":"<code>Products</code>","text":"<p>Class to handle/manage product instances and make those persistent.</p> <p>Attributes:</p> Name Type Description <code>store_path</code> <code>str</code> <p>The file path where products are stored as JSON.</p> <code>products</code> <code>List[Product]</code> <p>List of product instances.</p> <code>products_by_asin</code> <code>Dict[str, Product]</code> <p>Dictionary mapping ASIN to products.</p> <code>products_by_gtin</code> <code>Dict[str, Product]</code> <p>Dictionary mapping gtin to products.</p> Source code in <code>scan/product.py</code> <pre><code>class Products:\n    \"\"\"\n    Class to handle/manage product instances and make those persistent.\n\n    Attributes:\n        store_path (str): The file path where products are stored as JSON.\n        products (List[Product]): List of product instances.\n        products_by_asin (Dict[str, Product]): Dictionary mapping ASIN to products.\n        products_by_gtin (Dict[str, Product]): Dictionary mapping gtin to products.\n    \"\"\"\n\n    def __init__(self, store_path: str = None):\n        \"\"\"\n        Initialize the Products instance.\n\n        Args:\n            store_path (str, optional): The file path where products are stored as JSON.\n                                       Defaults to ~/.scan2wiki/products.json.\n        \"\"\"\n        self.store_path = store_path or expanduser(\"~/.scan2wiki/products.json\")\n        self.clear()\n\n    def clear(self):\n        \"\"\"\n        Clears the current product list and the associated mappings.\n        \"\"\"\n        self.products = []\n        self.products_by_asin = {}\n        self.products_by_gtin = {}\n\n    def add_product(self, product: Product):\n        \"\"\"\n        Adds a product to the product list and updates the mappings.\n        If a product with the same ASIN already exists, it updates the existing record.\n\n        Args:\n            product (Product): The product instance to add.\n        \"\"\"\n        # Update product if it already exists in the by_asin list\n        if product.asin and product.asin in self.products_by_asin:\n            existing_product = self.products_by_asin[product.asin]\n            existing_product.title = product.title\n            existing_product.image_url = product.image_url\n            existing_product.price = product.price\n            existing_product.gtin = product.gtin\n        else:\n            # Add the product to the list and mappings\n            self.products.append(product)\n            if product.asin:\n                self.products_by_asin[product.asin] = product\n            if product.gtin:\n                self.products_by_gtin[product.gtin] = product\n\n        # Sort the products list by ASIN\n        self.products.sort(key=lambda p: p.asin if p.asin else \"\")\n\n    def delete_product(self, asin: str):\n        \"\"\"\n        Delete a product with the given ASIN.\n\n        Args:\n            asin (str): The ASIN of the product to delete.\n        \"\"\"\n        # Delete the product from the products list\n        if asin in self.products.products_by_asin:\n            product = self.products.products_by_asin[asin]\n            self.products.products.remove(product)\n            del self.products.products_by_asin[asin]\n            if product.gtin and product.gtin in self.products.products_by_gtin:\n                del self.products.products_by_gtin[product.gtin]\n            self.products.save_to_json()  # Save the updated product list\n\n    def get_aggrid_lod(self) -&gt; List[Dict[str, str]]:\n        \"\"\"\n        Generates a list of dictionaries for ag-Grid representation of the products.\n\n        Returns:\n            List[Dict[str, str]]: List of product information formatted for ag-Grid.\n        \"\"\"\n        lod = []\n        for index, product in enumerate(self.products, start=1):\n            product_dict = {\n                \"#\": str(index),\n                \"Product\": product.as_html(),\n                \"ASIN\": Link.create(product.amazon_url, product.asin)\n                if product.asin\n                else \"\",\n                \"Title\": product.title,\n                \"gtin\": product.gtin if product.gtin else \"\",\n                \"Price\": product.price,\n            }\n            lod.append(product_dict)\n        return lod\n\n    def save_to_json(self, filename: str = None):\n        \"\"\"\n        Saves the current list of products to a JSON file.\n\n        Args:\n            filename (str, optional): The filename where to save the JSON data.\n                                      Defaults to the instance's store_path attribute.\n        \"\"\"\n\n        filename = filename or self.store_path\n        # Ensure the directory for the store_path exists\n        directory = dirname(filename)\n        if not exists(directory):\n            os.makedirs(directory, exist_ok=True)\n\n        product_data = [product.__dict__ for product in self.products]\n        with open(filename, \"w\") as file:\n            json.dump(product_data, file, indent=2)\n\n    def load_from_json(self, filepath: str = None):\n        \"\"\"\n        Loads products from a JSON file and updates the current list and mappings.\n\n        Args:\n            filepath (str, optional): The filepath from which to load the JSON data.\n                                      Defaults to the instance's store_path attribute.\n        \"\"\"\n        filename = filepath or self.store_path\n        if os.path.exists(filename):\n            with open(filename, \"r\") as file:\n                product_records = json.load(file)\n            for product_record in product_records:\n                self.add_product(Product(**product_record))\n</code></pre>"},{"location":"#scan.product.Products.__init__","title":"<code>__init__(store_path=None)</code>","text":"<p>Initialize the Products instance.</p> <p>Parameters:</p> Name Type Description Default <code>store_path</code> <code>str</code> <p>The file path where products are stored as JSON.                        Defaults to ~/.scan2wiki/products.json.</p> <code>None</code> Source code in <code>scan/product.py</code> <pre><code>def __init__(self, store_path: str = None):\n    \"\"\"\n    Initialize the Products instance.\n\n    Args:\n        store_path (str, optional): The file path where products are stored as JSON.\n                                   Defaults to ~/.scan2wiki/products.json.\n    \"\"\"\n    self.store_path = store_path or expanduser(\"~/.scan2wiki/products.json\")\n    self.clear()\n</code></pre>"},{"location":"#scan.product.Products.add_product","title":"<code>add_product(product)</code>","text":"<p>Adds a product to the product list and updates the mappings. If a product with the same ASIN already exists, it updates the existing record.</p> <p>Parameters:</p> Name Type Description Default <code>product</code> <code>Product</code> <p>The product instance to add.</p> required Source code in <code>scan/product.py</code> <pre><code>def add_product(self, product: Product):\n    \"\"\"\n    Adds a product to the product list and updates the mappings.\n    If a product with the same ASIN already exists, it updates the existing record.\n\n    Args:\n        product (Product): The product instance to add.\n    \"\"\"\n    # Update product if it already exists in the by_asin list\n    if product.asin and product.asin in self.products_by_asin:\n        existing_product = self.products_by_asin[product.asin]\n        existing_product.title = product.title\n        existing_product.image_url = product.image_url\n        existing_product.price = product.price\n        existing_product.gtin = product.gtin\n    else:\n        # Add the product to the list and mappings\n        self.products.append(product)\n        if product.asin:\n            self.products_by_asin[product.asin] = product\n        if product.gtin:\n            self.products_by_gtin[product.gtin] = product\n\n    # Sort the products list by ASIN\n    self.products.sort(key=lambda p: p.asin if p.asin else \"\")\n</code></pre>"},{"location":"#scan.product.Products.clear","title":"<code>clear()</code>","text":"<p>Clears the current product list and the associated mappings.</p> Source code in <code>scan/product.py</code> <pre><code>def clear(self):\n    \"\"\"\n    Clears the current product list and the associated mappings.\n    \"\"\"\n    self.products = []\n    self.products_by_asin = {}\n    self.products_by_gtin = {}\n</code></pre>"},{"location":"#scan.product.Products.delete_product","title":"<code>delete_product(asin)</code>","text":"<p>Delete a product with the given ASIN.</p> <p>Parameters:</p> Name Type Description Default <code>asin</code> <code>str</code> <p>The ASIN of the product to delete.</p> required Source code in <code>scan/product.py</code> <pre><code>def delete_product(self, asin: str):\n    \"\"\"\n    Delete a product with the given ASIN.\n\n    Args:\n        asin (str): The ASIN of the product to delete.\n    \"\"\"\n    # Delete the product from the products list\n    if asin in self.products.products_by_asin:\n        product = self.products.products_by_asin[asin]\n        self.products.products.remove(product)\n        del self.products.products_by_asin[asin]\n        if product.gtin and product.gtin in self.products.products_by_gtin:\n            del self.products.products_by_gtin[product.gtin]\n        self.products.save_to_json()  # Save the updated product list\n</code></pre>"},{"location":"#scan.product.Products.get_aggrid_lod","title":"<code>get_aggrid_lod()</code>","text":"<p>Generates a list of dictionaries for ag-Grid representation of the products.</p> <p>Returns:</p> Type Description <code>List[Dict[str, str]]</code> <p>List[Dict[str, str]]: List of product information formatted for ag-Grid.</p> Source code in <code>scan/product.py</code> <pre><code>def get_aggrid_lod(self) -&gt; List[Dict[str, str]]:\n    \"\"\"\n    Generates a list of dictionaries for ag-Grid representation of the products.\n\n    Returns:\n        List[Dict[str, str]]: List of product information formatted for ag-Grid.\n    \"\"\"\n    lod = []\n    for index, product in enumerate(self.products, start=1):\n        product_dict = {\n            \"#\": str(index),\n            \"Product\": product.as_html(),\n            \"ASIN\": Link.create(product.amazon_url, product.asin)\n            if product.asin\n            else \"\",\n            \"Title\": product.title,\n            \"gtin\": product.gtin if product.gtin else \"\",\n            \"Price\": product.price,\n        }\n        lod.append(product_dict)\n    return lod\n</code></pre>"},{"location":"#scan.product.Products.load_from_json","title":"<code>load_from_json(filepath=None)</code>","text":"<p>Loads products from a JSON file and updates the current list and mappings.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The filepath from which to load the JSON data.                       Defaults to the instance's store_path attribute.</p> <code>None</code> Source code in <code>scan/product.py</code> <pre><code>def load_from_json(self, filepath: str = None):\n    \"\"\"\n    Loads products from a JSON file and updates the current list and mappings.\n\n    Args:\n        filepath (str, optional): The filepath from which to load the JSON data.\n                                  Defaults to the instance's store_path attribute.\n    \"\"\"\n    filename = filepath or self.store_path\n    if os.path.exists(filename):\n        with open(filename, \"r\") as file:\n            product_records = json.load(file)\n        for product_record in product_records:\n            self.add_product(Product(**product_record))\n</code></pre>"},{"location":"#scan.product.Products.save_to_json","title":"<code>save_to_json(filename=None)</code>","text":"<p>Saves the current list of products to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename where to save the JSON data.                       Defaults to the instance's store_path attribute.</p> <code>None</code> Source code in <code>scan/product.py</code> <pre><code>def save_to_json(self, filename: str = None):\n    \"\"\"\n    Saves the current list of products to a JSON file.\n\n    Args:\n        filename (str, optional): The filename where to save the JSON data.\n                                  Defaults to the instance's store_path attribute.\n    \"\"\"\n\n    filename = filename or self.store_path\n    # Ensure the directory for the store_path exists\n    directory = dirname(filename)\n    if not exists(directory):\n        os.makedirs(directory, exist_ok=True)\n\n    product_data = [product.__dict__ for product in self.products]\n    with open(filename, \"w\") as file:\n        json.dump(product_data, file, indent=2)\n</code></pre>"},{"location":"#scan.profiler","title":"<code>profiler</code>","text":"<p>Created on 2021-10-26</p> <p>@author: wf</p>"},{"location":"#scan.profiler.Profiler","title":"<code>Profiler</code>","text":"<p>simple profiler</p> Source code in <code>scan/profiler.py</code> <pre><code>class Profiler:\n    \"\"\"\n    simple profiler\n    \"\"\"\n\n    def __init__(self, msg, profile=True):\n        \"\"\"\n        construct me with the given msg and profile active flag\n\n        Args:\n            msg(str): the message to show if profiling is active\n            profile(bool): True if messages should be shown\n        \"\"\"\n        self.msg = msg\n        self.profile = profile\n\n    def start(self) -&gt; str:\n        \"\"\"\n        start profiling\n\n        Return:\n            str: start message\n        \"\"\"\n        msg = f\"Starting {self.msg} ...\"\n        self.starttime = time.time()\n        if self.profile:\n            print(msg)\n        return msg\n\n    def time(self, extraMsg=\"\"):\n        \"\"\"\n        time the action and print if profile is active\n\n        Return:\n            (float,str): time and message for time\n        \"\"\"\n        elapsed = time.time() - self.starttime\n        elapsedMessage = f\"{self.msg}{extraMsg} took {elapsed:5.3f} s\"\n        if self.profile:\n            print(elapsedMessage)\n        return elapsed, elapsedMessage\n</code></pre>"},{"location":"#scan.profiler.Profiler.__init__","title":"<code>__init__(msg, profile=True)</code>","text":"<p>construct me with the given msg and profile active flag</p> <p>Parameters:</p> Name Type Description Default <code>msg(str)</code> <p>the message to show if profiling is active</p> required <code>profile(bool)</code> <p>True if messages should be shown</p> required Source code in <code>scan/profiler.py</code> <pre><code>def __init__(self, msg, profile=True):\n    \"\"\"\n    construct me with the given msg and profile active flag\n\n    Args:\n        msg(str): the message to show if profiling is active\n        profile(bool): True if messages should be shown\n    \"\"\"\n    self.msg = msg\n    self.profile = profile\n</code></pre>"},{"location":"#scan.profiler.Profiler.start","title":"<code>start()</code>","text":"<p>start profiling</p> Return <p>str: start message</p> Source code in <code>scan/profiler.py</code> <pre><code>def start(self) -&gt; str:\n    \"\"\"\n    start profiling\n\n    Return:\n        str: start message\n    \"\"\"\n    msg = f\"Starting {self.msg} ...\"\n    self.starttime = time.time()\n    if self.profile:\n        print(msg)\n    return msg\n</code></pre>"},{"location":"#scan.profiler.Profiler.time","title":"<code>time(extraMsg='')</code>","text":"<p>time the action and print if profile is active</p> Return <p>(float,str): time and message for time</p> Source code in <code>scan/profiler.py</code> <pre><code>def time(self, extraMsg=\"\"):\n    \"\"\"\n    time the action and print if profile is active\n\n    Return:\n        (float,str): time and message for time\n    \"\"\"\n    elapsed = time.time() - self.starttime\n    elapsedMessage = f\"{self.msg}{extraMsg} took {elapsed:5.3f} s\"\n    if self.profile:\n        print(elapsedMessage)\n    return elapsed, elapsedMessage\n</code></pre>"},{"location":"#scan.scan_cmd","title":"<code>scan_cmd</code>","text":"<p>Created on 2023-11-14</p> <p>@author: wf</p>"},{"location":"#scan.scan_cmd.ScanCmd","title":"<code>ScanCmd</code>","text":"<p>               Bases: <code>WebserverCmd</code></p> <p>Command line for scan2wiki web server</p> Source code in <code>scan/scan_cmd.py</code> <pre><code>class ScanCmd(WebserverCmd):\n    \"\"\"\n    Command line for scan2wiki web server\n    \"\"\"\n\n    def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n        \"\"\"\n        override the default argparser call\n        \"\"\"\n        parser = super().getArgParser(description, version_msg)\n        parser.add_argument(\n            \"-v\",\n            \"--verbose\",\n            action=\"store_true\",\n            help=\"show verbose output [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-rp\",\n            \"--root_path\",\n            default=ScanSolution.examples_path(),\n            help=\"path to example pdf files [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-wc\", \"--webcam\", help=\"url of webcam for scans [default: %(default)s]\"\n        )\n        return parser\n</code></pre>"},{"location":"#scan.scan_cmd.ScanCmd.getArgParser","title":"<code>getArgParser(description, version_msg)</code>","text":"<p>override the default argparser call</p> Source code in <code>scan/scan_cmd.py</code> <pre><code>def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n    \"\"\"\n    override the default argparser call\n    \"\"\"\n    parser = super().getArgParser(description, version_msg)\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"show verbose output [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-rp\",\n        \"--root_path\",\n        default=ScanSolution.examples_path(),\n        help=\"path to example pdf files [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-wc\", \"--webcam\", help=\"url of webcam for scans [default: %(default)s]\"\n    )\n    return parser\n</code></pre>"},{"location":"#scan.scan_cmd.main","title":"<code>main(argv=None)</code>","text":"<p>main call</p> Source code in <code>scan/scan_cmd.py</code> <pre><code>def main(argv: list = None):\n    \"\"\"\n    main call\n    \"\"\"\n    cmd = ScanCmd(config=ScanWebServer.get_config(), webserver_cls=ScanWebServer)\n    exit_code = cmd.cmd_main(argv)\n    return exit_code\n</code></pre>"},{"location":"#scan.scan_webserver","title":"<code>scan_webserver</code>","text":"<p>Created on 2023-11-14</p> <p>@author: wf</p>"},{"location":"#scan.scan_webserver.ScanSolution","title":"<code>ScanSolution</code>","text":"<p>               Bases: <code>InputWebSolution</code></p> <p>the Scan solution</p> Source code in <code>scan/scan_webserver.py</code> <pre><code>class ScanSolution(InputWebSolution):\n    \"\"\"\n    the Scan solution\n    \"\"\"\n\n    def __init__(self, webserver: ScanWebServer, client: Client):\n        \"\"\"\n        Initialize the solution\n\n        Calls the constructor of the base solution\n        Args:\n            webserver (ScanWebServer): The webserver instance associated with this context.\n            client (Client): The client instance this context is associated with.\n        \"\"\"\n        super().__init__(webserver, client)  # Call to the superclass constructor\n        self.stdout_handler = logging.StreamHandler(stream=sys.stdout)\n        self.stderr_handler = logging.StreamHandler(stream=sys.stderr)\n\n    async def setup_footer(self):\n        \"\"\"\n        add handlers for stdout and stderr\n        \"\"\"\n        await super().setup_footer(\n            with_log=True,\n            handle_logging=False,\n            max_lines=100,\n            log_classes=\"w-full h-20\",\n        )\n\n    async def webcam(self):\n        def setup_webcam():\n            self.webcam_form = WebcamForm(self, self.args.webcam)\n\n        await self.setup_content_div(setup_webcam)\n\n    async def upload(self, path: str = None):\n        \"\"\"\n        handle upload requests\n        \"\"\"\n\n        def setup_upload_form():\n            if path:\n                ui.notify(f\"upload of {path} requested\")\n            self.upload_form = UploadForm(self, self.webserver.wiki_users, path)\n\n        await self.setup_content_div(setup_upload_form)\n\n    @classmethod\n    def examples_path(cls) -&gt; str:\n        # the root directory (default: examples)\n        path = os.path.join(os.path.dirname(__file__), \"../scan2wiki_examples\")\n        path = os.path.abspath(path)\n        return path\n\n    def update_scans(self):\n        \"\"\"\n        update the scans grid\n        \"\"\"\n        try:\n            lod = self.webserver.scans.get_scan_files()\n            self.lod_grid.load_lod(lod)\n            self.lod_grid.sizeColumnsToFit()\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    async def show_archives(self):\n        \"\"\"\n        show archives\n        \"\"\"\n\n        def setup_show_archives():\n            \"\"\"\n            show the archives\n            \"\"\"\n            am_view = EntityManagerView(self.webserver.am)\n            am_view.show()\n\n        await self.setup_content_div(setup_show_archives)\n\n    def configure_menu(self):\n        \"\"\"\n        configure additional non-standard menu entries\n        \"\"\"\n        self.link_button(name=\"Webcam\", icon_name=\"photo_camera\", target=\"/webcam\")\n        self.link_button(name=\"Archives\", icon_name=\"database\", target=\"/archives\")\n        pass\n\n    async def home(self):\n        \"\"\"\n        provide the main content page\n        \"\"\"\n\n        def setup_home():\n            self.lod_grid = ListOfDictsGrid()\n            self.update_scans()\n\n        await (self.setup_content_div(setup_home))\n</code></pre>"},{"location":"#scan.scan_webserver.ScanSolution.__init__","title":"<code>__init__(webserver, client)</code>","text":"<p>Initialize the solution</p> <p>Calls the constructor of the base solution Args:     webserver (ScanWebServer): The webserver instance associated with this context.     client (Client): The client instance this context is associated with.</p> Source code in <code>scan/scan_webserver.py</code> <pre><code>def __init__(self, webserver: ScanWebServer, client: Client):\n    \"\"\"\n    Initialize the solution\n\n    Calls the constructor of the base solution\n    Args:\n        webserver (ScanWebServer): The webserver instance associated with this context.\n        client (Client): The client instance this context is associated with.\n    \"\"\"\n    super().__init__(webserver, client)  # Call to the superclass constructor\n    self.stdout_handler = logging.StreamHandler(stream=sys.stdout)\n    self.stderr_handler = logging.StreamHandler(stream=sys.stderr)\n</code></pre>"},{"location":"#scan.scan_webserver.ScanSolution.configure_menu","title":"<code>configure_menu()</code>","text":"<p>configure additional non-standard menu entries</p> Source code in <code>scan/scan_webserver.py</code> <pre><code>def configure_menu(self):\n    \"\"\"\n    configure additional non-standard menu entries\n    \"\"\"\n    self.link_button(name=\"Webcam\", icon_name=\"photo_camera\", target=\"/webcam\")\n    self.link_button(name=\"Archives\", icon_name=\"database\", target=\"/archives\")\n    pass\n</code></pre>"},{"location":"#scan.scan_webserver.ScanSolution.home","title":"<code>home()</code>  <code>async</code>","text":"<p>provide the main content page</p> Source code in <code>scan/scan_webserver.py</code> <pre><code>async def home(self):\n    \"\"\"\n    provide the main content page\n    \"\"\"\n\n    def setup_home():\n        self.lod_grid = ListOfDictsGrid()\n        self.update_scans()\n\n    await (self.setup_content_div(setup_home))\n</code></pre>"},{"location":"#scan.scan_webserver.ScanSolution.setup_footer","title":"<code>setup_footer()</code>  <code>async</code>","text":"<p>add handlers for stdout and stderr</p> Source code in <code>scan/scan_webserver.py</code> <pre><code>async def setup_footer(self):\n    \"\"\"\n    add handlers for stdout and stderr\n    \"\"\"\n    await super().setup_footer(\n        with_log=True,\n        handle_logging=False,\n        max_lines=100,\n        log_classes=\"w-full h-20\",\n    )\n</code></pre>"},{"location":"#scan.scan_webserver.ScanSolution.show_archives","title":"<code>show_archives()</code>  <code>async</code>","text":"<p>show archives</p> Source code in <code>scan/scan_webserver.py</code> <pre><code>async def show_archives(self):\n    \"\"\"\n    show archives\n    \"\"\"\n\n    def setup_show_archives():\n        \"\"\"\n        show the archives\n        \"\"\"\n        am_view = EntityManagerView(self.webserver.am)\n        am_view.show()\n\n    await self.setup_content_div(setup_show_archives)\n</code></pre>"},{"location":"#scan.scan_webserver.ScanSolution.update_scans","title":"<code>update_scans()</code>","text":"<p>update the scans grid</p> Source code in <code>scan/scan_webserver.py</code> <pre><code>def update_scans(self):\n    \"\"\"\n    update the scans grid\n    \"\"\"\n    try:\n        lod = self.webserver.scans.get_scan_files()\n        self.lod_grid.load_lod(lod)\n        self.lod_grid.sizeColumnsToFit()\n    except Exception as ex:\n        self.handle_exception(ex)\n</code></pre>"},{"location":"#scan.scan_webserver.ScanSolution.upload","title":"<code>upload(path=None)</code>  <code>async</code>","text":"<p>handle upload requests</p> Source code in <code>scan/scan_webserver.py</code> <pre><code>async def upload(self, path: str = None):\n    \"\"\"\n    handle upload requests\n    \"\"\"\n\n    def setup_upload_form():\n        if path:\n            ui.notify(f\"upload of {path} requested\")\n        self.upload_form = UploadForm(self, self.webserver.wiki_users, path)\n\n    await self.setup_content_div(setup_upload_form)\n</code></pre>"},{"location":"#scan.scan_webserver.ScanWebServer","title":"<code>ScanWebServer</code>","text":"<p>               Bases: <code>InputWebserver</code></p> <p>server for Document Management system with option to scan to Semantic Mediawikis</p> Source code in <code>scan/scan_webserver.py</code> <pre><code>class ScanWebServer(InputWebserver):\n    \"\"\"\n    server for Document Management system with option to scan to Semantic Mediawikis\n    \"\"\"\n\n    @classmethod\n    def get_config(cls) -&gt; WebserverConfig:\n        \"\"\"\n        get the configuration for this Webserver\n        \"\"\"\n        copy_right = \"(c)2020-2024 Wolfgang Fahl\"\n        config = WebserverConfig(\n            copy_right=copy_right, \n            version=Version(), \n            default_port=8334,\n            short_name=\"scan2wiki\",\n            timeout=10.0\n        )\n        server_config = WebserverConfig.get(config)\n        server_config.solution_class = ScanSolution\n        return server_config\n\n    def __init__(self):\n        \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n        InputWebserver.__init__(self, config=ScanWebServer.get_config())\n        self.scandir = DMSStorage.getScanDir()\n        self.scans = Scans(self.scandir)\n        self.wiki_users = WikiUser.getWikiUsers()\n        self.sql_db = DMSStorage.getSqlDB()\n        self.am = ArchiveManager.getInstance()\n        self.fm = FolderManager.getInstance()\n        self.dm = DocumentManager.getInstance()\n        self.archivesByName, _dup = self.am.getLookup(\"name\")\n\n        @ui.page(\"/upload/{path:path}\")\n        async def upload(client: Client, path: str = None):\n            return await self.page(\n                client, ScanSolution.upload,path\n            )\n\n        @ui.page(\"/webcam\")\n        async def webcam(client: Client):\n            return await self.page(\n                client, ScanSolution.webcam\n            )\n\n        @ui.page(\"/archives\")\n        async def show_archives(client: Client):\n            return await self.page(\n                client, ScanSolution.show_archives\n            )\n\n        @app.get(\"/delete/{path:path}\")\n        def delete(path: str = None):\n            self.scans.delete(path)\n            return RedirectResponse(\"/\")\n\n        @app.route(\"/files\")\n        @app.get(\"/files/{path:path}\")\n        def files(path: str = \".\"):\n            return self.files(path)\n\n    def files(self, path: str = \".\"):\n        \"\"\"\n        show the files in the given path\n\n        Args:\n            path(str): the path to render\n        \"\"\"\n        fullpath = f\"{self.scandir}/{path}\"\n        if os.path.isdir(fullpath):\n            self.scans = Scans(fullpath)\n            return RedirectResponse(\"/\")\n        elif os.path.isfile(fullpath):\n            file_response = FileResponse(fullpath)\n            return file_response\n        else:\n            msg = f\"invalid path: {path}\"\n            return HTMLResponse(content=msg, status_code=404)\n</code></pre>"},{"location":"#scan.scan_webserver.ScanWebServer.__init__","title":"<code>__init__()</code>","text":"<p>Constructs all the necessary attributes for the WebServer object.</p> Source code in <code>scan/scan_webserver.py</code> <pre><code>def __init__(self):\n    \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n    InputWebserver.__init__(self, config=ScanWebServer.get_config())\n    self.scandir = DMSStorage.getScanDir()\n    self.scans = Scans(self.scandir)\n    self.wiki_users = WikiUser.getWikiUsers()\n    self.sql_db = DMSStorage.getSqlDB()\n    self.am = ArchiveManager.getInstance()\n    self.fm = FolderManager.getInstance()\n    self.dm = DocumentManager.getInstance()\n    self.archivesByName, _dup = self.am.getLookup(\"name\")\n\n    @ui.page(\"/upload/{path:path}\")\n    async def upload(client: Client, path: str = None):\n        return await self.page(\n            client, ScanSolution.upload,path\n        )\n\n    @ui.page(\"/webcam\")\n    async def webcam(client: Client):\n        return await self.page(\n            client, ScanSolution.webcam\n        )\n\n    @ui.page(\"/archives\")\n    async def show_archives(client: Client):\n        return await self.page(\n            client, ScanSolution.show_archives\n        )\n\n    @app.get(\"/delete/{path:path}\")\n    def delete(path: str = None):\n        self.scans.delete(path)\n        return RedirectResponse(\"/\")\n\n    @app.route(\"/files\")\n    @app.get(\"/files/{path:path}\")\n    def files(path: str = \".\"):\n        return self.files(path)\n</code></pre>"},{"location":"#scan.scan_webserver.ScanWebServer.files","title":"<code>files(path='.')</code>","text":"<p>show the files in the given path</p> <p>Parameters:</p> Name Type Description Default <code>path(str)</code> <p>the path to render</p> required Source code in <code>scan/scan_webserver.py</code> <pre><code>def files(self, path: str = \".\"):\n    \"\"\"\n    show the files in the given path\n\n    Args:\n        path(str): the path to render\n    \"\"\"\n    fullpath = f\"{self.scandir}/{path}\"\n    if os.path.isdir(fullpath):\n        self.scans = Scans(fullpath)\n        return RedirectResponse(\"/\")\n    elif os.path.isfile(fullpath):\n        file_response = FileResponse(fullpath)\n        return file_response\n    else:\n        msg = f\"invalid path: {path}\"\n        return HTMLResponse(content=msg, status_code=404)\n</code></pre>"},{"location":"#scan.scan_webserver.ScanWebServer.get_config","title":"<code>get_config()</code>  <code>classmethod</code>","text":"<p>get the configuration for this Webserver</p> Source code in <code>scan/scan_webserver.py</code> <pre><code>@classmethod\ndef get_config(cls) -&gt; WebserverConfig:\n    \"\"\"\n    get the configuration for this Webserver\n    \"\"\"\n    copy_right = \"(c)2020-2024 Wolfgang Fahl\"\n    config = WebserverConfig(\n        copy_right=copy_right, \n        version=Version(), \n        default_port=8334,\n        short_name=\"scan2wiki\",\n        timeout=10.0\n    )\n    server_config = WebserverConfig.get(config)\n    server_config.solution_class = ScanSolution\n    return server_config\n</code></pre>"},{"location":"#scan.scans","title":"<code>scans</code>","text":"<p>Created on 2023-11-14</p> <p>@author: wf</p>"},{"location":"#scan.scans.Scans","title":"<code>Scans</code>","text":"<p>Class to handle operations related to scanned files.</p> Source code in <code>scan/scans.py</code> <pre><code>class Scans:\n    \"\"\"\n    Class to handle operations related to scanned files.\n    \"\"\"\n\n    def __init__(self, scandir: str):\n        \"\"\"\n        Initialize the Scans object.\n\n        Args:\n            scandir (str): The directory where the scanned files are located.\n        \"\"\"\n        self.scandir = scandir\n\n    def get_full_path(self, path: str) -&gt; str:\n        \"\"\"\n        Generate the full path for a given relative path.\n\n        Args:\n            path (str): The relative path to be resolved.\n\n        Returns:\n            str: The full path combining the scandir and the provided relative path.\n        \"\"\"\n        fullpath = os.path.join(self.scandir, path)\n        return fullpath\n\n    def get_file_link(self, path: str) -&gt; str:\n        \"\"\"\n        get a link to the given file\n\n        Args:\n            path(str) the path to the file\n\n        Returns:\n            str: The html markup for the RESTFul API to show the file\n        \"\"\"\n        url = f\"/files/{path}\"\n        link = Link.create(url, text=path)\n        return url, link\n\n    def get_scan_files(self) -&gt; List[Dict[str, object]]:\n        \"\"\"\n        Retrieve the scanned files information from the directory.\n\n        Returns:\n            List[Dict[str, object]]: A list of dictionaries, each representing a file.\n            Each dictionary contains details like file name, last modified time, size, and links for delete and upload actions.\n        \"\"\"\n        scan_files = []\n        for index, path in enumerate(os.listdir(self.scandir)):\n            try:\n                fullpath = self.get_full_path(path)\n                ftime = datetime.fromtimestamp(os.path.getmtime(fullpath))\n                ftimestr = ftime.strftime(\"%Y-%m-%d %H:%M:%S\")\n                size = os.path.getsize(fullpath)\n                _file_url, file_link = self.get_file_link(path)\n                scan_file = {\n                    \"#\": index + 1,\n                    \"name\": file_link,\n                    \"lastModified\": ftimestr,\n                    \"size\": size,\n                    \"delete\": Link.create(url=f\"/delete/{path}\", text=\"\u274c\"),\n                    \"upload\": Link.create(url=f\"/upload/{path}\", text=\"\u21e7\"),\n                }\n                scan_files.append(scan_file)\n            except Exception as ex:\n                msg = f\"error {str(ex)} for {path}\"\n                raise Exception(msg)\n        scan_files = sorted(scan_files, key=lambda x: x['lastModified'],reverse=True)\n        for index,scan_file in enumerate(scan_files):\n            scan_file[\"#\"]=index+1\n        return scan_files\n\n    def delete(self, path):\n        \"\"\"\n        Args:\n            path(str): the file to delete\n        \"\"\"\n        fullpath = self.get_full_path(path)\n        os.remove(fullpath)\n</code></pre>"},{"location":"#scan.scans.Scans.__init__","title":"<code>__init__(scandir)</code>","text":"<p>Initialize the Scans object.</p> <p>Parameters:</p> Name Type Description Default <code>scandir</code> <code>str</code> <p>The directory where the scanned files are located.</p> required Source code in <code>scan/scans.py</code> <pre><code>def __init__(self, scandir: str):\n    \"\"\"\n    Initialize the Scans object.\n\n    Args:\n        scandir (str): The directory where the scanned files are located.\n    \"\"\"\n    self.scandir = scandir\n</code></pre>"},{"location":"#scan.scans.Scans.delete","title":"<code>delete(path)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>path(str)</code> <p>the file to delete</p> required Source code in <code>scan/scans.py</code> <pre><code>def delete(self, path):\n    \"\"\"\n    Args:\n        path(str): the file to delete\n    \"\"\"\n    fullpath = self.get_full_path(path)\n    os.remove(fullpath)\n</code></pre>"},{"location":"#scan.scans.Scans.get_file_link","title":"<code>get_file_link(path)</code>","text":"<p>get a link to the given file</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The html markup for the RESTFul API to show the file</p> Source code in <code>scan/scans.py</code> <pre><code>def get_file_link(self, path: str) -&gt; str:\n    \"\"\"\n    get a link to the given file\n\n    Args:\n        path(str) the path to the file\n\n    Returns:\n        str: The html markup for the RESTFul API to show the file\n    \"\"\"\n    url = f\"/files/{path}\"\n    link = Link.create(url, text=path)\n    return url, link\n</code></pre>"},{"location":"#scan.scans.Scans.get_full_path","title":"<code>get_full_path(path)</code>","text":"<p>Generate the full path for a given relative path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The relative path to be resolved.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full path combining the scandir and the provided relative path.</p> Source code in <code>scan/scans.py</code> <pre><code>def get_full_path(self, path: str) -&gt; str:\n    \"\"\"\n    Generate the full path for a given relative path.\n\n    Args:\n        path (str): The relative path to be resolved.\n\n    Returns:\n        str: The full path combining the scandir and the provided relative path.\n    \"\"\"\n    fullpath = os.path.join(self.scandir, path)\n    return fullpath\n</code></pre>"},{"location":"#scan.scans.Scans.get_scan_files","title":"<code>get_scan_files()</code>","text":"<p>Retrieve the scanned files information from the directory.</p> <p>Returns:</p> Type Description <code>List[Dict[str, object]]</code> <p>List[Dict[str, object]]: A list of dictionaries, each representing a file.</p> <code>List[Dict[str, object]]</code> <p>Each dictionary contains details like file name, last modified time, size, and links for delete and upload actions.</p> Source code in <code>scan/scans.py</code> <pre><code>def get_scan_files(self) -&gt; List[Dict[str, object]]:\n    \"\"\"\n    Retrieve the scanned files information from the directory.\n\n    Returns:\n        List[Dict[str, object]]: A list of dictionaries, each representing a file.\n        Each dictionary contains details like file name, last modified time, size, and links for delete and upload actions.\n    \"\"\"\n    scan_files = []\n    for index, path in enumerate(os.listdir(self.scandir)):\n        try:\n            fullpath = self.get_full_path(path)\n            ftime = datetime.fromtimestamp(os.path.getmtime(fullpath))\n            ftimestr = ftime.strftime(\"%Y-%m-%d %H:%M:%S\")\n            size = os.path.getsize(fullpath)\n            _file_url, file_link = self.get_file_link(path)\n            scan_file = {\n                \"#\": index + 1,\n                \"name\": file_link,\n                \"lastModified\": ftimestr,\n                \"size\": size,\n                \"delete\": Link.create(url=f\"/delete/{path}\", text=\"\u274c\"),\n                \"upload\": Link.create(url=f\"/upload/{path}\", text=\"\u21e7\"),\n            }\n            scan_files.append(scan_file)\n        except Exception as ex:\n            msg = f\"error {str(ex)} for {path}\"\n            raise Exception(msg)\n    scan_files = sorted(scan_files, key=lambda x: x['lastModified'],reverse=True)\n    for index,scan_file in enumerate(scan_files):\n        scan_file[\"#\"]=index+1\n    return scan_files\n</code></pre>"},{"location":"#scan.upload","title":"<code>upload</code>","text":"<p>Created on 2023-11-14</p> <p>@author: wf</p>"},{"location":"#scan.upload.UploadForm","title":"<code>UploadForm</code>","text":"<p>upload form</p> Source code in <code>scan/upload.py</code> <pre><code>class UploadForm:\n    \"\"\"\n    upload form\n    \"\"\"\n\n    def __init__(self, solution, wiki_users: dict, path: str):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.solution=solution\n        self.webserver = solution.webserver\n        self.rem_value = 48  # Default rem value\n        self.red_link = \"color: red;text-decoration: underline;\"\n        self.blue_link = \"color: blue;text-decoration: underline;\"\n        self.debug = self.webserver.debug\n        self.scandir = self.webserver.scandir\n        self.scans = self.webserver.scans\n        self.wiki_users = wiki_users\n        self.path = path\n        self.doc = Document()\n        self.doc.fromFile(folderPath=self.scandir, file=path, local=True, withOcr=False)\n        self.setup_form()\n        self.upload_log_filter = UploadLogFilter(self.progressbar)\n        self.webserver.logger.addHandler(self.solution.stdout_handler)\n        self.webserver.logger.addHandler(self.solution.stderr_handler)\n        for logger_name in logging.Logger.manager.loggerDict:\n            # print(logger_name)\n            logger = logging.getLogger(logger_name)\n            logger.propagate = True\n            logger.addFilter(self.upload_log_filter)\n\n        self.uploaded = False\n        # self.pdfminer_logger = logging.getLogger('pdfminer')\n        # self.webserver.logger.addHandler(self.pdfminer_logger)\n\n    def setup_form(self):\n        \"\"\"\n        setup the upload form\n        \"\"\"\n        with ui.splitter(value=30).classes(\"h-fit\").style(\"flex:1\") as self.splitter:\n            with self.splitter.before:\n                self.progressbar = NiceguiProgressbar(\n                    100, \"processing page\", \"steps\"\n                )\n                with ui.card().tight():\n                    with ui.card_section():\n                        self.submit = ui.button(\"upload\", on_click=self.run_upload)\n                        self.ocr = ui.button(\"ocr\", on_click=self.run_ocr)\n                    with ui.card_section():\n                        self.page_title = (\n                            ui.input(\"pagetitle\", on_change=self.update)\n                            .props(\"size=80\")\n                            .bind_value_to(self.doc, \"pageTitle\")\n                        )\n                        self.page_link = ui.html(\"pagelink\").style(self.red_link)\n                        wiki_selection = list(sorted(self.wiki_users.keys()))\n                        self.wiki_user_select = self.solution.add_select(\n                            title=\"Wiki\",\n                            selection=wiki_selection,\n                            on_change=self.update,\n                        )\n                        (\n                            self.scanned_file_url,\n                            self.scanned_file_link,\n                        ) = self.scans.get_file_link(self.path)\n                        self.scanned_file_link_view = ui.html(\n                            self.scanned_file_link\n                        ).style(self.blue_link)\n                        current_date = datetime.now()\n                        self.categories = ui.input(\n                            \"categories\", value=str(current_date.year)\n                        ).bind_value_to(self.doc, \"categories\")\n                        self.topic = ui.input(\n                            \"topic\", value=\"OCRDocument\"\n                        ).bind_value_to(self.doc, \"topic\")\n            with self.splitter.after as self.pdf_container:\n                with ui.element(\"div\").classes(\"w-full h-full\"):\n                    self.ocr_text_area = (\n                        ui.textarea(\"Text\")\n                        .props(\"clearable\")\n                        .props(\"rows=25;cols=80\")\n                        .bind_value_to(self.doc, \"ocrText\")\n                    )\n                    ui.separator()\n                    self.rem_slider = ui.slider(\n                        min=10,\n                        max=100,\n                        step=1,\n                        value=self.rem_value,\n                        on_change=self.update_pdf_viewer_height,\n                    )\n                    # Embedding the PDF within a div that takes the full width and height\n                    pdf_html = f\"\"\"&lt;embed src=\"{self.scanned_file_url}\" type=\"application/pdf\" style=\"width:100%; height:100%;\"&gt;\"\"\"\n                    self.pdf_viewer = ui.html(pdf_html).classes(\"w-full h-[48rem]\")\n\n    async def run_ocr(self):\n        \"\"\"\n        run the optical character recognition\n        \"\"\"\n        try:\n            self.upload_log_filter.reset(1, 150)\n            time_msg = TimeMessage(f\"OCR for {self.doc.name} ({self.doc.size})\")\n            ui.notify(time_msg)\n            ocr_text = await run.io_bound(self.doc.getOcrText)\n            self.ocr_text_area.value = ocr_text\n            self.upload_log_filter.show_stats(self.solution.log_view)\n            ui.notify(time_msg.done())\n            self.update_progress(100)\n        except Exception as ex:\n            self.webserver.handle_exception(ex)\n\n    async def update_pdf_viewer_height(self, e):\n        \"\"\"\n        Update the height of the PDF viewer based on the slider value.\n        \"\"\"\n        self.rem_value = e.value\n        new_height = f\"h-[{self.rem_value}rem]\"  # Calculate the new height in rem\n        self.pdf_viewer.classes = f\"w-full {new_height}\"  # Update the PDF viewer height\n        self.splitter.update()\n\n    def update_progress(self, progress):\n        self.progressbar.value = progress\n\n    def update(self):\n        \"\"\"\n        update the page_link dependend on the page text or selected wiki\n        \"\"\"\n        page_title = self.page_title.value\n        wiki_id = self.wiki_user_select.value\n        if wiki_id in self.wiki_users:\n            wiki_user = self.wiki_users[wiki_id]\n            wiki_url = f\"{wiki_user.url}{wiki_user.scriptPath}\"\n            wiki_link = Link.create(f\"{wiki_url}/index.php/{page_title}\", page_title)\n            self.page_link.content = wiki_link\n            link_style = self.blue_link if self.uploaded else self.red_link\n            self.page_link.style(link_style)\n\n    def to_document(self, scandir, withOcr: bool = False):\n        \"\"\"\n        convert my content to a document\n        \"\"\"\n        doc = Document()\n        doc.fromFile(scandir, self.scanned_file.value, local=True, withOcr=withOcr)\n        doc.wikiUser = self.wiki_user_select.value\n        doc.categories = self.categories.value\n        if not withOcr:\n            doc.ocrText = self.ocr_text_area.value\n        return doc\n\n    async def run_upload(self):\n        \"\"\"\n        actually do the upload\n        \"\"\"\n        try:\n            uploadDoc = self.doc\n            self.upload_log_filter.reset(8, 1)\n            time_msg = TimeMessage(f\"uploading {uploadDoc.name} ({uploadDoc.size})\")\n            ui.notify(time_msg)\n            wiki_id = self.wiki_user_select.value\n            await run.io_bound(uploadDoc.uploadFile, wiki_id)\n            self.upload_log_filter.show_stats(self.solution.log_view)\n            ui.notify(time_msg.done())\n            # self.update_progress(100)\n            self.uploaded = True\n            self.update()\n        except Exception as ex:\n            self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#scan.upload.UploadForm.__init__","title":"<code>__init__(solution, wiki_users, path)</code>","text":"<p>constructor</p> Source code in <code>scan/upload.py</code> <pre><code>def __init__(self, solution, wiki_users: dict, path: str):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.solution=solution\n    self.webserver = solution.webserver\n    self.rem_value = 48  # Default rem value\n    self.red_link = \"color: red;text-decoration: underline;\"\n    self.blue_link = \"color: blue;text-decoration: underline;\"\n    self.debug = self.webserver.debug\n    self.scandir = self.webserver.scandir\n    self.scans = self.webserver.scans\n    self.wiki_users = wiki_users\n    self.path = path\n    self.doc = Document()\n    self.doc.fromFile(folderPath=self.scandir, file=path, local=True, withOcr=False)\n    self.setup_form()\n    self.upload_log_filter = UploadLogFilter(self.progressbar)\n    self.webserver.logger.addHandler(self.solution.stdout_handler)\n    self.webserver.logger.addHandler(self.solution.stderr_handler)\n    for logger_name in logging.Logger.manager.loggerDict:\n        # print(logger_name)\n        logger = logging.getLogger(logger_name)\n        logger.propagate = True\n        logger.addFilter(self.upload_log_filter)\n\n    self.uploaded = False\n</code></pre>"},{"location":"#scan.upload.UploadForm.run_ocr","title":"<code>run_ocr()</code>  <code>async</code>","text":"<p>run the optical character recognition</p> Source code in <code>scan/upload.py</code> <pre><code>async def run_ocr(self):\n    \"\"\"\n    run the optical character recognition\n    \"\"\"\n    try:\n        self.upload_log_filter.reset(1, 150)\n        time_msg = TimeMessage(f\"OCR for {self.doc.name} ({self.doc.size})\")\n        ui.notify(time_msg)\n        ocr_text = await run.io_bound(self.doc.getOcrText)\n        self.ocr_text_area.value = ocr_text\n        self.upload_log_filter.show_stats(self.solution.log_view)\n        ui.notify(time_msg.done())\n        self.update_progress(100)\n    except Exception as ex:\n        self.webserver.handle_exception(ex)\n</code></pre>"},{"location":"#scan.upload.UploadForm.run_upload","title":"<code>run_upload()</code>  <code>async</code>","text":"<p>actually do the upload</p> Source code in <code>scan/upload.py</code> <pre><code>async def run_upload(self):\n    \"\"\"\n    actually do the upload\n    \"\"\"\n    try:\n        uploadDoc = self.doc\n        self.upload_log_filter.reset(8, 1)\n        time_msg = TimeMessage(f\"uploading {uploadDoc.name} ({uploadDoc.size})\")\n        ui.notify(time_msg)\n        wiki_id = self.wiki_user_select.value\n        await run.io_bound(uploadDoc.uploadFile, wiki_id)\n        self.upload_log_filter.show_stats(self.solution.log_view)\n        ui.notify(time_msg.done())\n        # self.update_progress(100)\n        self.uploaded = True\n        self.update()\n    except Exception as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#scan.upload.UploadForm.setup_form","title":"<code>setup_form()</code>","text":"<p>setup the upload form</p> Source code in <code>scan/upload.py</code> <pre><code>def setup_form(self):\n    \"\"\"\n    setup the upload form\n    \"\"\"\n    with ui.splitter(value=30).classes(\"h-fit\").style(\"flex:1\") as self.splitter:\n        with self.splitter.before:\n            self.progressbar = NiceguiProgressbar(\n                100, \"processing page\", \"steps\"\n            )\n            with ui.card().tight():\n                with ui.card_section():\n                    self.submit = ui.button(\"upload\", on_click=self.run_upload)\n                    self.ocr = ui.button(\"ocr\", on_click=self.run_ocr)\n                with ui.card_section():\n                    self.page_title = (\n                        ui.input(\"pagetitle\", on_change=self.update)\n                        .props(\"size=80\")\n                        .bind_value_to(self.doc, \"pageTitle\")\n                    )\n                    self.page_link = ui.html(\"pagelink\").style(self.red_link)\n                    wiki_selection = list(sorted(self.wiki_users.keys()))\n                    self.wiki_user_select = self.solution.add_select(\n                        title=\"Wiki\",\n                        selection=wiki_selection,\n                        on_change=self.update,\n                    )\n                    (\n                        self.scanned_file_url,\n                        self.scanned_file_link,\n                    ) = self.scans.get_file_link(self.path)\n                    self.scanned_file_link_view = ui.html(\n                        self.scanned_file_link\n                    ).style(self.blue_link)\n                    current_date = datetime.now()\n                    self.categories = ui.input(\n                        \"categories\", value=str(current_date.year)\n                    ).bind_value_to(self.doc, \"categories\")\n                    self.topic = ui.input(\n                        \"topic\", value=\"OCRDocument\"\n                    ).bind_value_to(self.doc, \"topic\")\n        with self.splitter.after as self.pdf_container:\n            with ui.element(\"div\").classes(\"w-full h-full\"):\n                self.ocr_text_area = (\n                    ui.textarea(\"Text\")\n                    .props(\"clearable\")\n                    .props(\"rows=25;cols=80\")\n                    .bind_value_to(self.doc, \"ocrText\")\n                )\n                ui.separator()\n                self.rem_slider = ui.slider(\n                    min=10,\n                    max=100,\n                    step=1,\n                    value=self.rem_value,\n                    on_change=self.update_pdf_viewer_height,\n                )\n                # Embedding the PDF within a div that takes the full width and height\n                pdf_html = f\"\"\"&lt;embed src=\"{self.scanned_file_url}\" type=\"application/pdf\" style=\"width:100%; height:100%;\"&gt;\"\"\"\n                self.pdf_viewer = ui.html(pdf_html).classes(\"w-full h-[48rem]\")\n</code></pre>"},{"location":"#scan.upload.UploadForm.to_document","title":"<code>to_document(scandir, withOcr=False)</code>","text":"<p>convert my content to a document</p> Source code in <code>scan/upload.py</code> <pre><code>def to_document(self, scandir, withOcr: bool = False):\n    \"\"\"\n    convert my content to a document\n    \"\"\"\n    doc = Document()\n    doc.fromFile(scandir, self.scanned_file.value, local=True, withOcr=withOcr)\n    doc.wikiUser = self.wiki_user_select.value\n    doc.categories = self.categories.value\n    if not withOcr:\n        doc.ocrText = self.ocr_text_area.value\n    return doc\n</code></pre>"},{"location":"#scan.upload.UploadForm.update","title":"<code>update()</code>","text":"<p>update the page_link dependend on the page text or selected wiki</p> Source code in <code>scan/upload.py</code> <pre><code>def update(self):\n    \"\"\"\n    update the page_link dependend on the page text or selected wiki\n    \"\"\"\n    page_title = self.page_title.value\n    wiki_id = self.wiki_user_select.value\n    if wiki_id in self.wiki_users:\n        wiki_user = self.wiki_users[wiki_id]\n        wiki_url = f\"{wiki_user.url}{wiki_user.scriptPath}\"\n        wiki_link = Link.create(f\"{wiki_url}/index.php/{page_title}\", page_title)\n        self.page_link.content = wiki_link\n        link_style = self.blue_link if self.uploaded else self.red_link\n        self.page_link.style(link_style)\n</code></pre>"},{"location":"#scan.upload.UploadForm.update_pdf_viewer_height","title":"<code>update_pdf_viewer_height(e)</code>  <code>async</code>","text":"<p>Update the height of the PDF viewer based on the slider value.</p> Source code in <code>scan/upload.py</code> <pre><code>async def update_pdf_viewer_height(self, e):\n    \"\"\"\n    Update the height of the PDF viewer based on the slider value.\n    \"\"\"\n    self.rem_value = e.value\n    new_height = f\"h-[{self.rem_value}rem]\"  # Calculate the new height in rem\n    self.pdf_viewer.classes = f\"w-full {new_height}\"  # Update the PDF viewer height\n    self.splitter.update()\n</code></pre>"},{"location":"#scan.upload.UploadLogFilter","title":"<code>UploadLogFilter</code>","text":"<p>               Bases: <code>Filter</code></p> <p>logging filter for the Uploadform</p> Source code in <code>scan/upload.py</code> <pre><code>class UploadLogFilter(logging.Filter):\n    \"\"\"\n    logging filter for the Uploadform\n    \"\"\"\n\n    def __init__(self, progressbar):\n        super(UploadLogFilter, self).__init__()\n        self.progressbar = progressbar\n        self.reset()\n\n    def reset(self, progress_step: int = 1, per_log: int = 250):\n        self.progressbar.reset()\n        self.progress_step = progress_step\n        self.per_log = per_log\n        self.module_counter = Counter()\n\n    def show_stats(self, log_view):\n        \"\"\" \"\"\"\n        stats = self.module_counter.most_common()  # Get the most common modules\n        stats_str = \"\\n\".join([f\"{module}: {count} logs\" for module, count in stats])\n        if log_view:\n            log_view.push(stats_str)\n        pass\n\n    def filter(self, record):\n        self.module_counter[record.module] += 1\n        if sum(self.module_counter.values()) % self.per_log == 0:\n            self.progressbar.update(\n                self.progress_step\n            )  # Increment progress bar by stepsize\n        msg = str(record.msg).lower()\n        # make sure errors are still shown\n        if \"error\" in msg:\n            return False\n        return True  # Prevent standard logging\n</code></pre>"},{"location":"#scan.upload.UploadLogFilter.show_stats","title":"<code>show_stats(log_view)</code>","text":"Source code in <code>scan/upload.py</code> <pre><code>def show_stats(self, log_view):\n    \"\"\" \"\"\"\n    stats = self.module_counter.most_common()  # Get the most common modules\n    stats_str = \"\\n\".join([f\"{module}: {count} logs\" for module, count in stats])\n    if log_view:\n        log_view.push(stats_str)\n    pass\n</code></pre>"},{"location":"#scan.version","title":"<code>version</code>","text":"<p>Created on 2022-02-16</p> <p>@author: wf</p>"},{"location":"#scan.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for scan2wiki</p> Source code in <code>scan/version.py</code> <pre><code>@dataclass\nclass Version(object):\n    \"\"\"\n    Version handling for scan2wiki\n    \"\"\"\n\n    name = \"scan2wiki\"\n    version = scan.__version__\n    description = \"Scan to Wiki by watching a scan folder\"\n    date = \"2021-12-20\"\n    updated = \"2024-02-22\"\n\n    authors = \"Wolfgang Fahl\"\n\n    doc_url = \"https://wiki.bitplan.com/index.php/scan2wiki\"\n    chat_url = \"https://github.com/WolfgangFahl/scan2wiki/discussions\"\n    cm_url = \"https://github.com/WolfgangFahl/scan2wiki\"\n\n    license = f\"\"\"Copyright 2023 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#scan.webcam","title":"<code>webcam</code>","text":"<p>Created on 2023-11-16</p> <p>@author: wf</p>"},{"location":"#scan.webcam.WebcamForm","title":"<code>WebcamForm</code>","text":"<p>allow scanning pictures from a webcam</p> Source code in <code>scan/webcam.py</code> <pre><code>class WebcamForm:\n    \"\"\"\n    allow scanning pictures from a webcam\n    \"\"\"\n\n    def __init__(self, webserver, default_url: str):\n        \"\"\"\n        construct me\n        \"\"\"\n        self.webserver = webserver\n        self.scandir = webserver.scandir\n        self.url = default_url\n        self.shot_url = f\"{self.url}/shot.jpg\"\n        self.image_path = None\n        self.amazon = Amazon(self.webserver.debug)\n        self.product = None\n        self.gtin = None\n        self.products = Products()  # Initialize the Products instance\n        self.products.load_from_json()  # Load existing products\n        self.setup_form()\n        self.update_product_grid()\n\n    def notify(self, msg):\n        ui.notify(msg)\n        if self.webserver.log_view:\n            self.webserver.log_view.push(msg)\n\n    async def run_scan(self):\n        \"\"\"\n        Start the scan process in the background.\n        \"\"\"\n        _, scan_coro = self.task_handler.execute_in_background(self.save_webcam_shot)\n        self.image_path, msg = await scan_coro()\n        self.notify(msg)\n        self.update_preview(self.image_path)\n\n    def save_webcam_shot(self) -&gt; str:\n        \"\"\"\n        Fetches an image from the webcam URL and saves it with a timestamp in the specified directory.\n\n        Returns:\n            str: The file name of the saved webcam image, or an error message if the fetch failed.\n        \"\"\"\n        image_file_name = None\n        try:\n            shot_url = f\"{self.url}/shot.jpg\"\n            response = requests.get(shot_url)\n            if response.status_code == 200:\n                # Ensure the scandir directory exists\n                Path(self.scandir).mkdir(parents=True, exist_ok=True)\n                image_data = response.content\n                # Get current date and time without timezone information\n                timestamp = datetime.now().strftime(\"%Y-%m-%d_%H%M%S\")\n                # Define the full path to save the image\n                image_file_name = f\"webcam_{timestamp}.jpg\"\n                image_file_path = Path(self.scandir) / image_file_name\n                # Write the image data to the file system\n                with open(image_file_path, \"wb\") as image_file:\n                    image_file.write(image_data)\n                msg = f\"Saved webcam image to {image_file_path}\"\n            else:\n                msg = f\"Failed to fetch the webcam image. Status code: {response.status_code}\"\n                image_file_name = \"\"\n\n        except Exception as ex:\n            self.webserver.handle_exception(ex)\n\n        return image_file_name, msg\n\n    def setup_form(self):\n        \"\"\"\n        Setup the webcam form\n        \"\"\"\n        # Button to refresh or scan the video stream\n        self.scan_button = ui.button(\"Scan\", on_click=self.run_scan)\n        self.barcode_button = ui.button(\"Barcode\", on_click=self.scan_barcode)\n        self.lookup_button = ui.button(\"Lookup\", on_click=self.lookup_gtin)\n        self.add_button = ui.button(\"add\", on_click=self.add_product)\n        self.webcam_input = ui.input(value=self.url)\n        self.image_link = ui.html().style(Link.blue)\n        self.gtin_input = ui.input(\"gtin\", value=self.gtin).bind_value(self, \"gtin\")\n        self.barcode_results = ui.html(\"\")\n        self.product_grid = ListOfDictsGrid()\n        # HTML container for the webcam snap shot\n        self.preview = ui.html()\n\n    def update_product_grid(self):\n        \"\"\"\n        Update the product grid with the current products.\n        \"\"\"\n        lod = self.products.get_aggrid_lod()\n        self.product_grid.load_lod(lod)\n\n    async def add_product(self):\n        \"\"\"\n        add the given product\n        \"\"\"\n        self.products.add_product(self.product)\n        self.products.save_to_json()  # Save the updated product list\n        self.update_product_grid()  # Update the product grid\n\n    def lookup_gtin(self):\n        \"\"\"\n        lookup the  global trade identification number e.g. ean\n        \"\"\"\n        if not self.gtin:\n            return\n        # Perform Amazon lookup for gtin\n        amazon_products = self.amazon.lookup_products(self.gtin)\n        if amazon_products:\n            # Assuming you want to display the first product found for each barcode\n            self.product = amazon_products[0]\n            self.product.gtin = self.gtin\n            product_html = self.product.as_html()\n            product_details = product_html\n            msg = f\"found {self.product.title} for gtin {self.gtin}\"\n        else:\n            msg = f\"No matching Amazon product found for gtin {self.gtin}.\"\n            product_details = f\"&lt;p&gt;{msg}&lt;/p&gt;\"\n\n        html_markup = f\"&lt;p&gt;Code: {self.gtin}, {product_details}&lt;/p&gt;\"\n        self.notify(msg)\n        self.barcode_results.content = html_markup\n\n    async def scan_barcode(self):\n        \"\"\"\n        Scan for barcodes in the most recently saved webcam image and look up products on Amazon.\n        \"\"\"\n        try:\n            if self.image_path:\n                barcode_path = f\"{self.scandir}/{self.image_path}\"\n                barcode_list = Barcode.decode(barcode_path)\n                if barcode_list and len(barcode_list) &gt;= 1:\n                    barcode = barcode_list[0]\n                    self.gtin_input.value = barcode.code\n                    msg = f\"barcode {barcode.code} type {barcode.type} found\"\n                else:\n                    msg = \"No barcodes found.\"\n            else:\n                msg = \"No image to scan for barcodes.\"\n            self.notify(msg)\n        except Exception as ex:\n            self.webserver.handle_exception(ex)\n\n    def update_preview(self, image_path: str = None):\n        \"\"\"\n        Update the preview with the current URL of the webcam.\n        \"\"\"\n        if image_path:\n            url = f\"/files/{image_path}\"\n            html_markup = f\"\"\"&lt;img src=\"{url}\" style=\"width: 100%; height: auto;\" /&gt;\"\"\"\n            self.image_link.content = Link.create(url, image_path)\n            self.preview.content = html_markup\n        else:\n            self.preview.content = \"Loading...\"\n</code></pre>"},{"location":"#scan.webcam.WebcamForm.__init__","title":"<code>__init__(webserver, default_url)</code>","text":"<p>construct me</p> Source code in <code>scan/webcam.py</code> <pre><code>def __init__(self, webserver, default_url: str):\n    \"\"\"\n    construct me\n    \"\"\"\n    self.webserver = webserver\n    self.scandir = webserver.scandir\n    self.url = default_url\n    self.shot_url = f\"{self.url}/shot.jpg\"\n    self.image_path = None\n    self.amazon = Amazon(self.webserver.debug)\n    self.product = None\n    self.gtin = None\n    self.products = Products()  # Initialize the Products instance\n    self.products.load_from_json()  # Load existing products\n    self.setup_form()\n    self.update_product_grid()\n</code></pre>"},{"location":"#scan.webcam.WebcamForm.add_product","title":"<code>add_product()</code>  <code>async</code>","text":"<p>add the given product</p> Source code in <code>scan/webcam.py</code> <pre><code>async def add_product(self):\n    \"\"\"\n    add the given product\n    \"\"\"\n    self.products.add_product(self.product)\n    self.products.save_to_json()  # Save the updated product list\n    self.update_product_grid()  # Update the product grid\n</code></pre>"},{"location":"#scan.webcam.WebcamForm.lookup_gtin","title":"<code>lookup_gtin()</code>","text":"<p>lookup the  global trade identification number e.g. ean</p> Source code in <code>scan/webcam.py</code> <pre><code>def lookup_gtin(self):\n    \"\"\"\n    lookup the  global trade identification number e.g. ean\n    \"\"\"\n    if not self.gtin:\n        return\n    # Perform Amazon lookup for gtin\n    amazon_products = self.amazon.lookup_products(self.gtin)\n    if amazon_products:\n        # Assuming you want to display the first product found for each barcode\n        self.product = amazon_products[0]\n        self.product.gtin = self.gtin\n        product_html = self.product.as_html()\n        product_details = product_html\n        msg = f\"found {self.product.title} for gtin {self.gtin}\"\n    else:\n        msg = f\"No matching Amazon product found for gtin {self.gtin}.\"\n        product_details = f\"&lt;p&gt;{msg}&lt;/p&gt;\"\n\n    html_markup = f\"&lt;p&gt;Code: {self.gtin}, {product_details}&lt;/p&gt;\"\n    self.notify(msg)\n    self.barcode_results.content = html_markup\n</code></pre>"},{"location":"#scan.webcam.WebcamForm.run_scan","title":"<code>run_scan()</code>  <code>async</code>","text":"<p>Start the scan process in the background.</p> Source code in <code>scan/webcam.py</code> <pre><code>async def run_scan(self):\n    \"\"\"\n    Start the scan process in the background.\n    \"\"\"\n    _, scan_coro = self.task_handler.execute_in_background(self.save_webcam_shot)\n    self.image_path, msg = await scan_coro()\n    self.notify(msg)\n    self.update_preview(self.image_path)\n</code></pre>"},{"location":"#scan.webcam.WebcamForm.save_webcam_shot","title":"<code>save_webcam_shot()</code>","text":"<p>Fetches an image from the webcam URL and saves it with a timestamp in the specified directory.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The file name of the saved webcam image, or an error message if the fetch failed.</p> Source code in <code>scan/webcam.py</code> <pre><code>def save_webcam_shot(self) -&gt; str:\n    \"\"\"\n    Fetches an image from the webcam URL and saves it with a timestamp in the specified directory.\n\n    Returns:\n        str: The file name of the saved webcam image, or an error message if the fetch failed.\n    \"\"\"\n    image_file_name = None\n    try:\n        shot_url = f\"{self.url}/shot.jpg\"\n        response = requests.get(shot_url)\n        if response.status_code == 200:\n            # Ensure the scandir directory exists\n            Path(self.scandir).mkdir(parents=True, exist_ok=True)\n            image_data = response.content\n            # Get current date and time without timezone information\n            timestamp = datetime.now().strftime(\"%Y-%m-%d_%H%M%S\")\n            # Define the full path to save the image\n            image_file_name = f\"webcam_{timestamp}.jpg\"\n            image_file_path = Path(self.scandir) / image_file_name\n            # Write the image data to the file system\n            with open(image_file_path, \"wb\") as image_file:\n                image_file.write(image_data)\n            msg = f\"Saved webcam image to {image_file_path}\"\n        else:\n            msg = f\"Failed to fetch the webcam image. Status code: {response.status_code}\"\n            image_file_name = \"\"\n\n    except Exception as ex:\n        self.webserver.handle_exception(ex)\n\n    return image_file_name, msg\n</code></pre>"},{"location":"#scan.webcam.WebcamForm.scan_barcode","title":"<code>scan_barcode()</code>  <code>async</code>","text":"<p>Scan for barcodes in the most recently saved webcam image and look up products on Amazon.</p> Source code in <code>scan/webcam.py</code> <pre><code>async def scan_barcode(self):\n    \"\"\"\n    Scan for barcodes in the most recently saved webcam image and look up products on Amazon.\n    \"\"\"\n    try:\n        if self.image_path:\n            barcode_path = f\"{self.scandir}/{self.image_path}\"\n            barcode_list = Barcode.decode(barcode_path)\n            if barcode_list and len(barcode_list) &gt;= 1:\n                barcode = barcode_list[0]\n                self.gtin_input.value = barcode.code\n                msg = f\"barcode {barcode.code} type {barcode.type} found\"\n            else:\n                msg = \"No barcodes found.\"\n        else:\n            msg = \"No image to scan for barcodes.\"\n        self.notify(msg)\n    except Exception as ex:\n        self.webserver.handle_exception(ex)\n</code></pre>"},{"location":"#scan.webcam.WebcamForm.setup_form","title":"<code>setup_form()</code>","text":"<p>Setup the webcam form</p> Source code in <code>scan/webcam.py</code> <pre><code>def setup_form(self):\n    \"\"\"\n    Setup the webcam form\n    \"\"\"\n    # Button to refresh or scan the video stream\n    self.scan_button = ui.button(\"Scan\", on_click=self.run_scan)\n    self.barcode_button = ui.button(\"Barcode\", on_click=self.scan_barcode)\n    self.lookup_button = ui.button(\"Lookup\", on_click=self.lookup_gtin)\n    self.add_button = ui.button(\"add\", on_click=self.add_product)\n    self.webcam_input = ui.input(value=self.url)\n    self.image_link = ui.html().style(Link.blue)\n    self.gtin_input = ui.input(\"gtin\", value=self.gtin).bind_value(self, \"gtin\")\n    self.barcode_results = ui.html(\"\")\n    self.product_grid = ListOfDictsGrid()\n    # HTML container for the webcam snap shot\n    self.preview = ui.html()\n</code></pre>"},{"location":"#scan.webcam.WebcamForm.update_preview","title":"<code>update_preview(image_path=None)</code>","text":"<p>Update the preview with the current URL of the webcam.</p> Source code in <code>scan/webcam.py</code> <pre><code>def update_preview(self, image_path: str = None):\n    \"\"\"\n    Update the preview with the current URL of the webcam.\n    \"\"\"\n    if image_path:\n        url = f\"/files/{image_path}\"\n        html_markup = f\"\"\"&lt;img src=\"{url}\" style=\"width: 100%; height: auto;\" /&gt;\"\"\"\n        self.image_link.content = Link.create(url, image_path)\n        self.preview.content = html_markup\n    else:\n        self.preview.content = \"Loading...\"\n</code></pre>"},{"location":"#scan.webcam.WebcamForm.update_product_grid","title":"<code>update_product_grid()</code>","text":"<p>Update the product grid with the current products.</p> Source code in <code>scan/webcam.py</code> <pre><code>def update_product_grid(self):\n    \"\"\"\n    Update the product grid with the current products.\n    \"\"\"\n    lod = self.products.get_aggrid_lod()\n    self.product_grid.load_lod(lod)\n</code></pre>"}]}